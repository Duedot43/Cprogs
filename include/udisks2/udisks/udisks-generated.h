/*
 * This file is generated by gdbus-codegen, do not modify it.
 *
 * The license of this code is the same as for the D-Bus interface description
 * it was derived from. Note that it links to GLib, so must comply with the
 * LGPL linking clauses.
 */

#ifndef __UDISKS_GENERATED_H__
#define __UDISKS_GENERATED_H__

#include <gio/gio.h>

G_BEGIN_DECLS


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Manager */

#define UDISKS_TYPE_MANAGER (udisks_manager_get_type ())
#define UDISKS_MANAGER(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_MANAGER, UDisksManager))
#define UDISKS_IS_MANAGER(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_MANAGER))
#define UDISKS_MANAGER_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_MANAGER, UDisksManagerIface))

struct _UDisksManager;
typedef struct _UDisksManager UDisksManager;
typedef struct _UDisksManagerIface UDisksManagerIface;

struct _UDisksManagerIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_enable_modules) (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    gboolean arg_enable);

  gboolean (*handle_loop_setup) (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    GUnixFDList *fd_list,
    GVariant *arg_fd,
    GVariant *arg_options);

  const gchar * (*get_default_encryption_type) (UDisksManager *object);

  const gchar *const * (*get_supported_encryption_types) (UDisksManager *object);

  const gchar *const * (*get_supported_filesystems) (UDisksManager *object);

  const gchar * (*get_version) (UDisksManager *object);

  gboolean (*handle_mdraid_create) (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    const gchar *const *arg_blocks,
    const gchar *arg_level,
    const gchar *arg_name,
    guint64 arg_chunk,
    GVariant *arg_options);

  gboolean (*handle_can_check) (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_type);

  gboolean (*handle_can_format) (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_type);

  gboolean (*handle_can_repair) (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_type);

  gboolean (*handle_can_resize) (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_type);

  gboolean (*handle_get_block_devices) (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_resolve_device) (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_devspec,
    GVariant *arg_options);

  gboolean (*handle_enable_module) (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_name,
    gboolean arg_enable);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksManager, g_object_unref)
#endif

GType udisks_manager_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_manager_interface_info (void);
guint udisks_manager_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_manager_complete_can_format (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    GVariant *available);

void udisks_manager_complete_can_resize (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    GVariant *available);

void udisks_manager_complete_can_check (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    GVariant *available);

void udisks_manager_complete_can_repair (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    GVariant *available);

void udisks_manager_complete_loop_setup (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    GUnixFDList *fd_list,
    const gchar *resulting_device);

void udisks_manager_complete_mdraid_create (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    const gchar *resulting_array);

G_GNUC_DEPRECATED void udisks_manager_complete_enable_modules (
    UDisksManager *object,
    GDBusMethodInvocation *invocation);

void udisks_manager_complete_enable_module (
    UDisksManager *object,
    GDBusMethodInvocation *invocation);

void udisks_manager_complete_get_block_devices (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    const gchar *const *block_objects);

void udisks_manager_complete_resolve_device (
    UDisksManager *object,
    GDBusMethodInvocation *invocation,
    const gchar *const *devices);



/* D-Bus method calls: */
void udisks_manager_call_can_format (
    UDisksManager *proxy,
    const gchar *arg_type,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_manager_call_can_format_finish (
    UDisksManager *proxy,
    GVariant **out_available,
    GAsyncResult *res,
    GError **error);

gboolean udisks_manager_call_can_format_sync (
    UDisksManager *proxy,
    const gchar *arg_type,
    GVariant **out_available,
    GCancellable *cancellable,
    GError **error);

void udisks_manager_call_can_resize (
    UDisksManager *proxy,
    const gchar *arg_type,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_manager_call_can_resize_finish (
    UDisksManager *proxy,
    GVariant **out_available,
    GAsyncResult *res,
    GError **error);

gboolean udisks_manager_call_can_resize_sync (
    UDisksManager *proxy,
    const gchar *arg_type,
    GVariant **out_available,
    GCancellable *cancellable,
    GError **error);

void udisks_manager_call_can_check (
    UDisksManager *proxy,
    const gchar *arg_type,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_manager_call_can_check_finish (
    UDisksManager *proxy,
    GVariant **out_available,
    GAsyncResult *res,
    GError **error);

gboolean udisks_manager_call_can_check_sync (
    UDisksManager *proxy,
    const gchar *arg_type,
    GVariant **out_available,
    GCancellable *cancellable,
    GError **error);

void udisks_manager_call_can_repair (
    UDisksManager *proxy,
    const gchar *arg_type,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_manager_call_can_repair_finish (
    UDisksManager *proxy,
    GVariant **out_available,
    GAsyncResult *res,
    GError **error);

gboolean udisks_manager_call_can_repair_sync (
    UDisksManager *proxy,
    const gchar *arg_type,
    GVariant **out_available,
    GCancellable *cancellable,
    GError **error);

void udisks_manager_call_loop_setup (
    UDisksManager *proxy,
    GVariant *arg_fd,
    GVariant *arg_options,
    GUnixFDList *fd_list,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_manager_call_loop_setup_finish (
    UDisksManager *proxy,
    gchar **out_resulting_device,
    GUnixFDList **out_fd_list,
    GAsyncResult *res,
    GError **error);

gboolean udisks_manager_call_loop_setup_sync (
    UDisksManager *proxy,
    GVariant *arg_fd,
    GVariant *arg_options,
    GUnixFDList  *fd_list,
    gchar **out_resulting_device,
    GUnixFDList **out_fd_list,
    GCancellable *cancellable,
    GError **error);

void udisks_manager_call_mdraid_create (
    UDisksManager *proxy,
    const gchar *const *arg_blocks,
    const gchar *arg_level,
    const gchar *arg_name,
    guint64 arg_chunk,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_manager_call_mdraid_create_finish (
    UDisksManager *proxy,
    gchar **out_resulting_array,
    GAsyncResult *res,
    GError **error);

gboolean udisks_manager_call_mdraid_create_sync (
    UDisksManager *proxy,
    const gchar *const *arg_blocks,
    const gchar *arg_level,
    const gchar *arg_name,
    guint64 arg_chunk,
    GVariant *arg_options,
    gchar **out_resulting_array,
    GCancellable *cancellable,
    GError **error);

G_GNUC_DEPRECATED void udisks_manager_call_enable_modules (
    UDisksManager *proxy,
    gboolean arg_enable,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

G_GNUC_DEPRECATED gboolean udisks_manager_call_enable_modules_finish (
    UDisksManager *proxy,
    GAsyncResult *res,
    GError **error);

G_GNUC_DEPRECATED gboolean udisks_manager_call_enable_modules_sync (
    UDisksManager *proxy,
    gboolean arg_enable,
    GCancellable *cancellable,
    GError **error);

void udisks_manager_call_enable_module (
    UDisksManager *proxy,
    const gchar *arg_name,
    gboolean arg_enable,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_manager_call_enable_module_finish (
    UDisksManager *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_manager_call_enable_module_sync (
    UDisksManager *proxy,
    const gchar *arg_name,
    gboolean arg_enable,
    GCancellable *cancellable,
    GError **error);

void udisks_manager_call_get_block_devices (
    UDisksManager *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_manager_call_get_block_devices_finish (
    UDisksManager *proxy,
    gchar ***out_block_objects,
    GAsyncResult *res,
    GError **error);

gboolean udisks_manager_call_get_block_devices_sync (
    UDisksManager *proxy,
    GVariant *arg_options,
    gchar ***out_block_objects,
    GCancellable *cancellable,
    GError **error);

void udisks_manager_call_resolve_device (
    UDisksManager *proxy,
    GVariant *arg_devspec,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_manager_call_resolve_device_finish (
    UDisksManager *proxy,
    gchar ***out_devices,
    GAsyncResult *res,
    GError **error);

gboolean udisks_manager_call_resolve_device_sync (
    UDisksManager *proxy,
    GVariant *arg_devspec,
    GVariant *arg_options,
    gchar ***out_devices,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
const gchar *udisks_manager_get_version (UDisksManager *object);
gchar *udisks_manager_dup_version (UDisksManager *object);
void udisks_manager_set_version (UDisksManager *object, const gchar *value);

const gchar *const *udisks_manager_get_supported_filesystems (UDisksManager *object);
gchar **udisks_manager_dup_supported_filesystems (UDisksManager *object);
void udisks_manager_set_supported_filesystems (UDisksManager *object, const gchar *const *value);

const gchar *const *udisks_manager_get_supported_encryption_types (UDisksManager *object);
gchar **udisks_manager_dup_supported_encryption_types (UDisksManager *object);
void udisks_manager_set_supported_encryption_types (UDisksManager *object, const gchar *const *value);

const gchar *udisks_manager_get_default_encryption_type (UDisksManager *object);
gchar *udisks_manager_dup_default_encryption_type (UDisksManager *object);
void udisks_manager_set_default_encryption_type (UDisksManager *object, const gchar *value);


/* ---- */

#define UDISKS_TYPE_MANAGER_PROXY (udisks_manager_proxy_get_type ())
#define UDISKS_MANAGER_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_MANAGER_PROXY, UDisksManagerProxy))
#define UDISKS_MANAGER_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_MANAGER_PROXY, UDisksManagerProxyClass))
#define UDISKS_MANAGER_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_MANAGER_PROXY, UDisksManagerProxyClass))
#define UDISKS_IS_MANAGER_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_MANAGER_PROXY))
#define UDISKS_IS_MANAGER_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_MANAGER_PROXY))

typedef struct _UDisksManagerProxy UDisksManagerProxy;
typedef struct _UDisksManagerProxyClass UDisksManagerProxyClass;
typedef struct _UDisksManagerProxyPrivate UDisksManagerProxyPrivate;

struct _UDisksManagerProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksManagerProxyPrivate *priv;
};

struct _UDisksManagerProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_manager_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksManagerProxy, g_object_unref)
#endif

void udisks_manager_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksManager *udisks_manager_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksManager *udisks_manager_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_manager_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksManager *udisks_manager_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksManager *udisks_manager_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_MANAGER_SKELETON (udisks_manager_skeleton_get_type ())
#define UDISKS_MANAGER_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_MANAGER_SKELETON, UDisksManagerSkeleton))
#define UDISKS_MANAGER_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_MANAGER_SKELETON, UDisksManagerSkeletonClass))
#define UDISKS_MANAGER_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_MANAGER_SKELETON, UDisksManagerSkeletonClass))
#define UDISKS_IS_MANAGER_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_MANAGER_SKELETON))
#define UDISKS_IS_MANAGER_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_MANAGER_SKELETON))

typedef struct _UDisksManagerSkeleton UDisksManagerSkeleton;
typedef struct _UDisksManagerSkeletonClass UDisksManagerSkeletonClass;
typedef struct _UDisksManagerSkeletonPrivate UDisksManagerSkeletonPrivate;

struct _UDisksManagerSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksManagerSkeletonPrivate *priv;
};

struct _UDisksManagerSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_manager_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksManagerSkeleton, g_object_unref)
#endif

UDisksManager *udisks_manager_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Drive */

#define UDISKS_TYPE_DRIVE (udisks_drive_get_type ())
#define UDISKS_DRIVE(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_DRIVE, UDisksDrive))
#define UDISKS_IS_DRIVE(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_DRIVE))
#define UDISKS_DRIVE_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_DRIVE, UDisksDriveIface))

struct _UDisksDrive;
typedef struct _UDisksDrive UDisksDrive;
typedef struct _UDisksDriveIface UDisksDriveIface;

struct _UDisksDriveIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_eject) (
    UDisksDrive *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_set_configuration) (
    UDisksDrive *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_value,
    GVariant *arg_options);

  GVariant * (*get_configuration) (UDisksDrive *object);

  const gchar * (*get_connection_bus) (UDisksDrive *object);

  gboolean  (*get_ejectable) (UDisksDrive *object);

  const gchar * (*get_id) (UDisksDrive *object);

  const gchar * (*get_media) (UDisksDrive *object);

  gboolean  (*get_media_available) (UDisksDrive *object);

  gboolean  (*get_media_change_detected) (UDisksDrive *object);

  const gchar *const * (*get_media_compatibility) (UDisksDrive *object);

  gboolean  (*get_media_removable) (UDisksDrive *object);

  const gchar * (*get_model) (UDisksDrive *object);

  gboolean  (*get_optical) (UDisksDrive *object);

  gboolean  (*get_optical_blank) (UDisksDrive *object);

  guint  (*get_optical_num_audio_tracks) (UDisksDrive *object);

  guint  (*get_optical_num_data_tracks) (UDisksDrive *object);

  guint  (*get_optical_num_sessions) (UDisksDrive *object);

  guint  (*get_optical_num_tracks) (UDisksDrive *object);

  gboolean  (*get_removable) (UDisksDrive *object);

  const gchar * (*get_revision) (UDisksDrive *object);

  gint  (*get_rotation_rate) (UDisksDrive *object);

  const gchar * (*get_seat) (UDisksDrive *object);

  const gchar * (*get_serial) (UDisksDrive *object);

  guint64  (*get_size) (UDisksDrive *object);

  const gchar * (*get_sort_key) (UDisksDrive *object);

  guint64  (*get_time_detected) (UDisksDrive *object);

  guint64  (*get_time_media_detected) (UDisksDrive *object);

  const gchar * (*get_vendor) (UDisksDrive *object);

  const gchar * (*get_wwn) (UDisksDrive *object);

  gboolean (*handle_power_off) (
    UDisksDrive *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean  (*get_can_power_off) (UDisksDrive *object);

  const gchar * (*get_sibling_id) (UDisksDrive *object);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksDrive, g_object_unref)
#endif

GType udisks_drive_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_drive_interface_info (void);
guint udisks_drive_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_drive_complete_eject (
    UDisksDrive *object,
    GDBusMethodInvocation *invocation);

void udisks_drive_complete_set_configuration (
    UDisksDrive *object,
    GDBusMethodInvocation *invocation);

void udisks_drive_complete_power_off (
    UDisksDrive *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void udisks_drive_call_eject (
    UDisksDrive *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_drive_call_eject_finish (
    UDisksDrive *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_drive_call_eject_sync (
    UDisksDrive *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_drive_call_set_configuration (
    UDisksDrive *proxy,
    GVariant *arg_value,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_drive_call_set_configuration_finish (
    UDisksDrive *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_drive_call_set_configuration_sync (
    UDisksDrive *proxy,
    GVariant *arg_value,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_drive_call_power_off (
    UDisksDrive *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_drive_call_power_off_finish (
    UDisksDrive *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_drive_call_power_off_sync (
    UDisksDrive *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
const gchar *udisks_drive_get_vendor (UDisksDrive *object);
gchar *udisks_drive_dup_vendor (UDisksDrive *object);
void udisks_drive_set_vendor (UDisksDrive *object, const gchar *value);

const gchar *udisks_drive_get_model (UDisksDrive *object);
gchar *udisks_drive_dup_model (UDisksDrive *object);
void udisks_drive_set_model (UDisksDrive *object, const gchar *value);

const gchar *udisks_drive_get_revision (UDisksDrive *object);
gchar *udisks_drive_dup_revision (UDisksDrive *object);
void udisks_drive_set_revision (UDisksDrive *object, const gchar *value);

const gchar *udisks_drive_get_serial (UDisksDrive *object);
gchar *udisks_drive_dup_serial (UDisksDrive *object);
void udisks_drive_set_serial (UDisksDrive *object, const gchar *value);

const gchar *udisks_drive_get_wwn (UDisksDrive *object);
gchar *udisks_drive_dup_wwn (UDisksDrive *object);
void udisks_drive_set_wwn (UDisksDrive *object, const gchar *value);

const gchar *udisks_drive_get_id (UDisksDrive *object);
gchar *udisks_drive_dup_id (UDisksDrive *object);
void udisks_drive_set_id (UDisksDrive *object, const gchar *value);

GVariant *udisks_drive_get_configuration (UDisksDrive *object);
GVariant *udisks_drive_dup_configuration (UDisksDrive *object);
void udisks_drive_set_configuration (UDisksDrive *object, GVariant *value);

const gchar *udisks_drive_get_media (UDisksDrive *object);
gchar *udisks_drive_dup_media (UDisksDrive *object);
void udisks_drive_set_media (UDisksDrive *object, const gchar *value);

const gchar *const *udisks_drive_get_media_compatibility (UDisksDrive *object);
gchar **udisks_drive_dup_media_compatibility (UDisksDrive *object);
void udisks_drive_set_media_compatibility (UDisksDrive *object, const gchar *const *value);

gboolean udisks_drive_get_media_removable (UDisksDrive *object);
void udisks_drive_set_media_removable (UDisksDrive *object, gboolean value);

gboolean udisks_drive_get_media_available (UDisksDrive *object);
void udisks_drive_set_media_available (UDisksDrive *object, gboolean value);

gboolean udisks_drive_get_media_change_detected (UDisksDrive *object);
void udisks_drive_set_media_change_detected (UDisksDrive *object, gboolean value);

guint64 udisks_drive_get_size (UDisksDrive *object);
void udisks_drive_set_size (UDisksDrive *object, guint64 value);

guint64 udisks_drive_get_time_detected (UDisksDrive *object);
void udisks_drive_set_time_detected (UDisksDrive *object, guint64 value);

guint64 udisks_drive_get_time_media_detected (UDisksDrive *object);
void udisks_drive_set_time_media_detected (UDisksDrive *object, guint64 value);

gboolean udisks_drive_get_optical (UDisksDrive *object);
void udisks_drive_set_optical (UDisksDrive *object, gboolean value);

gboolean udisks_drive_get_optical_blank (UDisksDrive *object);
void udisks_drive_set_optical_blank (UDisksDrive *object, gboolean value);

guint udisks_drive_get_optical_num_tracks (UDisksDrive *object);
void udisks_drive_set_optical_num_tracks (UDisksDrive *object, guint value);

guint udisks_drive_get_optical_num_audio_tracks (UDisksDrive *object);
void udisks_drive_set_optical_num_audio_tracks (UDisksDrive *object, guint value);

guint udisks_drive_get_optical_num_data_tracks (UDisksDrive *object);
void udisks_drive_set_optical_num_data_tracks (UDisksDrive *object, guint value);

guint udisks_drive_get_optical_num_sessions (UDisksDrive *object);
void udisks_drive_set_optical_num_sessions (UDisksDrive *object, guint value);

gint udisks_drive_get_rotation_rate (UDisksDrive *object);
void udisks_drive_set_rotation_rate (UDisksDrive *object, gint value);

const gchar *udisks_drive_get_connection_bus (UDisksDrive *object);
gchar *udisks_drive_dup_connection_bus (UDisksDrive *object);
void udisks_drive_set_connection_bus (UDisksDrive *object, const gchar *value);

const gchar *udisks_drive_get_seat (UDisksDrive *object);
gchar *udisks_drive_dup_seat (UDisksDrive *object);
void udisks_drive_set_seat (UDisksDrive *object, const gchar *value);

gboolean udisks_drive_get_removable (UDisksDrive *object);
void udisks_drive_set_removable (UDisksDrive *object, gboolean value);

gboolean udisks_drive_get_ejectable (UDisksDrive *object);
void udisks_drive_set_ejectable (UDisksDrive *object, gboolean value);

const gchar *udisks_drive_get_sort_key (UDisksDrive *object);
gchar *udisks_drive_dup_sort_key (UDisksDrive *object);
void udisks_drive_set_sort_key (UDisksDrive *object, const gchar *value);

gboolean udisks_drive_get_can_power_off (UDisksDrive *object);
void udisks_drive_set_can_power_off (UDisksDrive *object, gboolean value);

const gchar *udisks_drive_get_sibling_id (UDisksDrive *object);
gchar *udisks_drive_dup_sibling_id (UDisksDrive *object);
void udisks_drive_set_sibling_id (UDisksDrive *object, const gchar *value);


/* ---- */

#define UDISKS_TYPE_DRIVE_PROXY (udisks_drive_proxy_get_type ())
#define UDISKS_DRIVE_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_DRIVE_PROXY, UDisksDriveProxy))
#define UDISKS_DRIVE_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_DRIVE_PROXY, UDisksDriveProxyClass))
#define UDISKS_DRIVE_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_DRIVE_PROXY, UDisksDriveProxyClass))
#define UDISKS_IS_DRIVE_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_DRIVE_PROXY))
#define UDISKS_IS_DRIVE_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_DRIVE_PROXY))

typedef struct _UDisksDriveProxy UDisksDriveProxy;
typedef struct _UDisksDriveProxyClass UDisksDriveProxyClass;
typedef struct _UDisksDriveProxyPrivate UDisksDriveProxyPrivate;

struct _UDisksDriveProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksDriveProxyPrivate *priv;
};

struct _UDisksDriveProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_drive_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksDriveProxy, g_object_unref)
#endif

void udisks_drive_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksDrive *udisks_drive_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksDrive *udisks_drive_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_drive_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksDrive *udisks_drive_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksDrive *udisks_drive_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_DRIVE_SKELETON (udisks_drive_skeleton_get_type ())
#define UDISKS_DRIVE_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_DRIVE_SKELETON, UDisksDriveSkeleton))
#define UDISKS_DRIVE_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_DRIVE_SKELETON, UDisksDriveSkeletonClass))
#define UDISKS_DRIVE_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_DRIVE_SKELETON, UDisksDriveSkeletonClass))
#define UDISKS_IS_DRIVE_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_DRIVE_SKELETON))
#define UDISKS_IS_DRIVE_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_DRIVE_SKELETON))

typedef struct _UDisksDriveSkeleton UDisksDriveSkeleton;
typedef struct _UDisksDriveSkeletonClass UDisksDriveSkeletonClass;
typedef struct _UDisksDriveSkeletonPrivate UDisksDriveSkeletonPrivate;

struct _UDisksDriveSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksDriveSkeletonPrivate *priv;
};

struct _UDisksDriveSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_drive_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksDriveSkeleton, g_object_unref)
#endif

UDisksDrive *udisks_drive_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Drive.Ata */

#define UDISKS_TYPE_DRIVE_ATA (udisks_drive_ata_get_type ())
#define UDISKS_DRIVE_ATA(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_DRIVE_ATA, UDisksDriveAta))
#define UDISKS_IS_DRIVE_ATA(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_DRIVE_ATA))
#define UDISKS_DRIVE_ATA_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_DRIVE_ATA, UDisksDriveAtaIface))

struct _UDisksDriveAta;
typedef struct _UDisksDriveAta UDisksDriveAta;
typedef struct _UDisksDriveAtaIface UDisksDriveAtaIface;

struct _UDisksDriveAtaIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_pm_get_state) (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_pm_standby) (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_pm_wakeup) (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_security_erase_unit) (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_smart_get_attributes) (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_smart_selftest_abort) (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_smart_selftest_start) (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_type,
    GVariant *arg_options);

  gboolean (*handle_smart_update) (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean  (*get_aam_enabled) (UDisksDriveAta *object);

  gboolean  (*get_aam_supported) (UDisksDriveAta *object);

  gint  (*get_aam_vendor_recommended_value) (UDisksDriveAta *object);

  gboolean  (*get_apm_enabled) (UDisksDriveAta *object);

  gboolean  (*get_apm_supported) (UDisksDriveAta *object);

  gboolean  (*get_pm_enabled) (UDisksDriveAta *object);

  gboolean  (*get_pm_supported) (UDisksDriveAta *object);

  gint  (*get_security_enhanced_erase_unit_minutes) (UDisksDriveAta *object);

  gint  (*get_security_erase_unit_minutes) (UDisksDriveAta *object);

  gboolean  (*get_security_frozen) (UDisksDriveAta *object);

  gboolean  (*get_smart_enabled) (UDisksDriveAta *object);

  gboolean  (*get_smart_failing) (UDisksDriveAta *object);

  gint  (*get_smart_num_attributes_failed_in_the_past) (UDisksDriveAta *object);

  gint  (*get_smart_num_attributes_failing) (UDisksDriveAta *object);

  gint64  (*get_smart_num_bad_sectors) (UDisksDriveAta *object);

  guint64  (*get_smart_power_on_seconds) (UDisksDriveAta *object);

  gint  (*get_smart_selftest_percent_remaining) (UDisksDriveAta *object);

  const gchar * (*get_smart_selftest_status) (UDisksDriveAta *object);

  gboolean  (*get_smart_supported) (UDisksDriveAta *object);

  gdouble  (*get_smart_temperature) (UDisksDriveAta *object);

  guint64  (*get_smart_updated) (UDisksDriveAta *object);

  gboolean (*handle_smart_set_enabled) (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation,
    gboolean arg_value,
    GVariant *arg_options);

  gboolean  (*get_write_cache_enabled) (UDisksDriveAta *object);

  gboolean  (*get_write_cache_supported) (UDisksDriveAta *object);

  gboolean  (*get_read_lookahead_enabled) (UDisksDriveAta *object);

  gboolean  (*get_read_lookahead_supported) (UDisksDriveAta *object);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksDriveAta, g_object_unref)
#endif

GType udisks_drive_ata_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_drive_ata_interface_info (void);
guint udisks_drive_ata_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_drive_ata_complete_smart_update (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation);

void udisks_drive_ata_complete_smart_get_attributes (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation,
    GVariant *attributes);

void udisks_drive_ata_complete_smart_selftest_start (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation);

void udisks_drive_ata_complete_smart_selftest_abort (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation);

void udisks_drive_ata_complete_smart_set_enabled (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation);

void udisks_drive_ata_complete_pm_get_state (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation,
    guchar state);

void udisks_drive_ata_complete_pm_standby (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation);

void udisks_drive_ata_complete_pm_wakeup (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation);

void udisks_drive_ata_complete_security_erase_unit (
    UDisksDriveAta *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void udisks_drive_ata_call_smart_update (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_drive_ata_call_smart_update_finish (
    UDisksDriveAta *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_drive_ata_call_smart_update_sync (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_drive_ata_call_smart_get_attributes (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_drive_ata_call_smart_get_attributes_finish (
    UDisksDriveAta *proxy,
    GVariant **out_attributes,
    GAsyncResult *res,
    GError **error);

gboolean udisks_drive_ata_call_smart_get_attributes_sync (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    GVariant **out_attributes,
    GCancellable *cancellable,
    GError **error);

void udisks_drive_ata_call_smart_selftest_start (
    UDisksDriveAta *proxy,
    const gchar *arg_type,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_drive_ata_call_smart_selftest_start_finish (
    UDisksDriveAta *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_drive_ata_call_smart_selftest_start_sync (
    UDisksDriveAta *proxy,
    const gchar *arg_type,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_drive_ata_call_smart_selftest_abort (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_drive_ata_call_smart_selftest_abort_finish (
    UDisksDriveAta *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_drive_ata_call_smart_selftest_abort_sync (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_drive_ata_call_smart_set_enabled (
    UDisksDriveAta *proxy,
    gboolean arg_value,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_drive_ata_call_smart_set_enabled_finish (
    UDisksDriveAta *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_drive_ata_call_smart_set_enabled_sync (
    UDisksDriveAta *proxy,
    gboolean arg_value,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_drive_ata_call_pm_get_state (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_drive_ata_call_pm_get_state_finish (
    UDisksDriveAta *proxy,
    guchar *out_state,
    GAsyncResult *res,
    GError **error);

gboolean udisks_drive_ata_call_pm_get_state_sync (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    guchar *out_state,
    GCancellable *cancellable,
    GError **error);

void udisks_drive_ata_call_pm_standby (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_drive_ata_call_pm_standby_finish (
    UDisksDriveAta *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_drive_ata_call_pm_standby_sync (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_drive_ata_call_pm_wakeup (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_drive_ata_call_pm_wakeup_finish (
    UDisksDriveAta *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_drive_ata_call_pm_wakeup_sync (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_drive_ata_call_security_erase_unit (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_drive_ata_call_security_erase_unit_finish (
    UDisksDriveAta *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_drive_ata_call_security_erase_unit_sync (
    UDisksDriveAta *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
gboolean udisks_drive_ata_get_smart_supported (UDisksDriveAta *object);
void udisks_drive_ata_set_smart_supported (UDisksDriveAta *object, gboolean value);

gboolean udisks_drive_ata_get_smart_enabled (UDisksDriveAta *object);
void udisks_drive_ata_set_smart_enabled (UDisksDriveAta *object, gboolean value);

guint64 udisks_drive_ata_get_smart_updated (UDisksDriveAta *object);
void udisks_drive_ata_set_smart_updated (UDisksDriveAta *object, guint64 value);

gboolean udisks_drive_ata_get_smart_failing (UDisksDriveAta *object);
void udisks_drive_ata_set_smart_failing (UDisksDriveAta *object, gboolean value);

guint64 udisks_drive_ata_get_smart_power_on_seconds (UDisksDriveAta *object);
void udisks_drive_ata_set_smart_power_on_seconds (UDisksDriveAta *object, guint64 value);

gdouble udisks_drive_ata_get_smart_temperature (UDisksDriveAta *object);
void udisks_drive_ata_set_smart_temperature (UDisksDriveAta *object, gdouble value);

gint udisks_drive_ata_get_smart_num_attributes_failing (UDisksDriveAta *object);
void udisks_drive_ata_set_smart_num_attributes_failing (UDisksDriveAta *object, gint value);

gint udisks_drive_ata_get_smart_num_attributes_failed_in_the_past (UDisksDriveAta *object);
void udisks_drive_ata_set_smart_num_attributes_failed_in_the_past (UDisksDriveAta *object, gint value);

gint64 udisks_drive_ata_get_smart_num_bad_sectors (UDisksDriveAta *object);
void udisks_drive_ata_set_smart_num_bad_sectors (UDisksDriveAta *object, gint64 value);

const gchar *udisks_drive_ata_get_smart_selftest_status (UDisksDriveAta *object);
gchar *udisks_drive_ata_dup_smart_selftest_status (UDisksDriveAta *object);
void udisks_drive_ata_set_smart_selftest_status (UDisksDriveAta *object, const gchar *value);

gint udisks_drive_ata_get_smart_selftest_percent_remaining (UDisksDriveAta *object);
void udisks_drive_ata_set_smart_selftest_percent_remaining (UDisksDriveAta *object, gint value);

gboolean udisks_drive_ata_get_pm_supported (UDisksDriveAta *object);
void udisks_drive_ata_set_pm_supported (UDisksDriveAta *object, gboolean value);

gboolean udisks_drive_ata_get_pm_enabled (UDisksDriveAta *object);
void udisks_drive_ata_set_pm_enabled (UDisksDriveAta *object, gboolean value);

gboolean udisks_drive_ata_get_apm_supported (UDisksDriveAta *object);
void udisks_drive_ata_set_apm_supported (UDisksDriveAta *object, gboolean value);

gboolean udisks_drive_ata_get_apm_enabled (UDisksDriveAta *object);
void udisks_drive_ata_set_apm_enabled (UDisksDriveAta *object, gboolean value);

gboolean udisks_drive_ata_get_aam_supported (UDisksDriveAta *object);
void udisks_drive_ata_set_aam_supported (UDisksDriveAta *object, gboolean value);

gboolean udisks_drive_ata_get_aam_enabled (UDisksDriveAta *object);
void udisks_drive_ata_set_aam_enabled (UDisksDriveAta *object, gboolean value);

gint udisks_drive_ata_get_aam_vendor_recommended_value (UDisksDriveAta *object);
void udisks_drive_ata_set_aam_vendor_recommended_value (UDisksDriveAta *object, gint value);

gboolean udisks_drive_ata_get_write_cache_supported (UDisksDriveAta *object);
void udisks_drive_ata_set_write_cache_supported (UDisksDriveAta *object, gboolean value);

gboolean udisks_drive_ata_get_write_cache_enabled (UDisksDriveAta *object);
void udisks_drive_ata_set_write_cache_enabled (UDisksDriveAta *object, gboolean value);

gboolean udisks_drive_ata_get_read_lookahead_supported (UDisksDriveAta *object);
void udisks_drive_ata_set_read_lookahead_supported (UDisksDriveAta *object, gboolean value);

gboolean udisks_drive_ata_get_read_lookahead_enabled (UDisksDriveAta *object);
void udisks_drive_ata_set_read_lookahead_enabled (UDisksDriveAta *object, gboolean value);

gint udisks_drive_ata_get_security_erase_unit_minutes (UDisksDriveAta *object);
void udisks_drive_ata_set_security_erase_unit_minutes (UDisksDriveAta *object, gint value);

gint udisks_drive_ata_get_security_enhanced_erase_unit_minutes (UDisksDriveAta *object);
void udisks_drive_ata_set_security_enhanced_erase_unit_minutes (UDisksDriveAta *object, gint value);

gboolean udisks_drive_ata_get_security_frozen (UDisksDriveAta *object);
void udisks_drive_ata_set_security_frozen (UDisksDriveAta *object, gboolean value);


/* ---- */

#define UDISKS_TYPE_DRIVE_ATA_PROXY (udisks_drive_ata_proxy_get_type ())
#define UDISKS_DRIVE_ATA_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_DRIVE_ATA_PROXY, UDisksDriveAtaProxy))
#define UDISKS_DRIVE_ATA_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_DRIVE_ATA_PROXY, UDisksDriveAtaProxyClass))
#define UDISKS_DRIVE_ATA_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_DRIVE_ATA_PROXY, UDisksDriveAtaProxyClass))
#define UDISKS_IS_DRIVE_ATA_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_DRIVE_ATA_PROXY))
#define UDISKS_IS_DRIVE_ATA_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_DRIVE_ATA_PROXY))

typedef struct _UDisksDriveAtaProxy UDisksDriveAtaProxy;
typedef struct _UDisksDriveAtaProxyClass UDisksDriveAtaProxyClass;
typedef struct _UDisksDriveAtaProxyPrivate UDisksDriveAtaProxyPrivate;

struct _UDisksDriveAtaProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksDriveAtaProxyPrivate *priv;
};

struct _UDisksDriveAtaProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_drive_ata_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksDriveAtaProxy, g_object_unref)
#endif

void udisks_drive_ata_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksDriveAta *udisks_drive_ata_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksDriveAta *udisks_drive_ata_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_drive_ata_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksDriveAta *udisks_drive_ata_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksDriveAta *udisks_drive_ata_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_DRIVE_ATA_SKELETON (udisks_drive_ata_skeleton_get_type ())
#define UDISKS_DRIVE_ATA_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_DRIVE_ATA_SKELETON, UDisksDriveAtaSkeleton))
#define UDISKS_DRIVE_ATA_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_DRIVE_ATA_SKELETON, UDisksDriveAtaSkeletonClass))
#define UDISKS_DRIVE_ATA_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_DRIVE_ATA_SKELETON, UDisksDriveAtaSkeletonClass))
#define UDISKS_IS_DRIVE_ATA_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_DRIVE_ATA_SKELETON))
#define UDISKS_IS_DRIVE_ATA_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_DRIVE_ATA_SKELETON))

typedef struct _UDisksDriveAtaSkeleton UDisksDriveAtaSkeleton;
typedef struct _UDisksDriveAtaSkeletonClass UDisksDriveAtaSkeletonClass;
typedef struct _UDisksDriveAtaSkeletonPrivate UDisksDriveAtaSkeletonPrivate;

struct _UDisksDriveAtaSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksDriveAtaSkeletonPrivate *priv;
};

struct _UDisksDriveAtaSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_drive_ata_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksDriveAtaSkeleton, g_object_unref)
#endif

UDisksDriveAta *udisks_drive_ata_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Block */

#define UDISKS_TYPE_BLOCK (udisks_block_get_type ())
#define UDISKS_BLOCK(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_BLOCK, UDisksBlock))
#define UDISKS_IS_BLOCK(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_BLOCK))
#define UDISKS_BLOCK_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_BLOCK, UDisksBlockIface))

struct _UDisksBlock;
typedef struct _UDisksBlock UDisksBlock;
typedef struct _UDisksBlockIface UDisksBlockIface;

struct _UDisksBlockIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_add_configuration_item) (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_item,
    GVariant *arg_options);

  gboolean (*handle_format) (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_type,
    GVariant *arg_options);

  gboolean (*handle_get_secret_configuration) (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_open_for_backup) (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GUnixFDList *fd_list,
    GVariant *arg_options);

  gboolean (*handle_open_for_benchmark) (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GUnixFDList *fd_list,
    GVariant *arg_options);

  gboolean (*handle_open_for_restore) (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GUnixFDList *fd_list,
    GVariant *arg_options);

  gboolean (*handle_remove_configuration_item) (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_item,
    GVariant *arg_options);

  gboolean (*handle_rescan) (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_update_configuration_item) (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_old_item,
    GVariant *arg_new_item,
    GVariant *arg_options);

  GVariant * (*get_configuration) (UDisksBlock *object);

  const gchar * (*get_crypto_backing_device) (UDisksBlock *object);

  const gchar * (*get_device) (UDisksBlock *object);

  guint64  (*get_device_number) (UDisksBlock *object);

  const gchar * (*get_drive) (UDisksBlock *object);

  gboolean  (*get_hint_auto) (UDisksBlock *object);

  const gchar * (*get_hint_icon_name) (UDisksBlock *object);

  gboolean  (*get_hint_ignore) (UDisksBlock *object);

  const gchar * (*get_hint_name) (UDisksBlock *object);

  gboolean  (*get_hint_partitionable) (UDisksBlock *object);

  gboolean  (*get_hint_system) (UDisksBlock *object);

  const gchar * (*get_id_label) (UDisksBlock *object);

  const gchar * (*get_id_type) (UDisksBlock *object);

  const gchar * (*get_id_usage) (UDisksBlock *object);

  const gchar * (*get_id_uuid) (UDisksBlock *object);

  const gchar * (*get_id_version) (UDisksBlock *object);

  const gchar * (*get_preferred_device) (UDisksBlock *object);

  gboolean  (*get_read_only) (UDisksBlock *object);

  guint64  (*get_size) (UDisksBlock *object);

  const gchar *const * (*get_symlinks) (UDisksBlock *object);

  const gchar *const * (*get_userspace_mount_options) (UDisksBlock *object);

  const gchar * (*get_hint_symbolic_icon_name) (UDisksBlock *object);

  const gchar * (*get_id) (UDisksBlock *object);

  const gchar * (*get_mdraid) (UDisksBlock *object);

  const gchar * (*get_mdraid_member) (UDisksBlock *object);

  gboolean (*handle_open_device) (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GUnixFDList *fd_list,
    const gchar *arg_mode,
    GVariant *arg_options);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksBlock, g_object_unref)
#endif

GType udisks_block_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_block_interface_info (void);
guint udisks_block_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_block_complete_add_configuration_item (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation);

void udisks_block_complete_remove_configuration_item (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation);

void udisks_block_complete_update_configuration_item (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation);

void udisks_block_complete_get_secret_configuration (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GVariant *configuration);

void udisks_block_complete_format (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation);

void udisks_block_complete_open_for_backup (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GUnixFDList *fd_list,
    GVariant *fd);

void udisks_block_complete_open_for_restore (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GUnixFDList *fd_list,
    GVariant *fd);

void udisks_block_complete_open_for_benchmark (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GUnixFDList *fd_list,
    GVariant *fd);

void udisks_block_complete_open_device (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation,
    GUnixFDList *fd_list,
    GVariant *fd);

void udisks_block_complete_rescan (
    UDisksBlock *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void udisks_block_call_add_configuration_item (
    UDisksBlock *proxy,
    GVariant *arg_item,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_block_call_add_configuration_item_finish (
    UDisksBlock *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_block_call_add_configuration_item_sync (
    UDisksBlock *proxy,
    GVariant *arg_item,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_block_call_remove_configuration_item (
    UDisksBlock *proxy,
    GVariant *arg_item,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_block_call_remove_configuration_item_finish (
    UDisksBlock *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_block_call_remove_configuration_item_sync (
    UDisksBlock *proxy,
    GVariant *arg_item,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_block_call_update_configuration_item (
    UDisksBlock *proxy,
    GVariant *arg_old_item,
    GVariant *arg_new_item,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_block_call_update_configuration_item_finish (
    UDisksBlock *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_block_call_update_configuration_item_sync (
    UDisksBlock *proxy,
    GVariant *arg_old_item,
    GVariant *arg_new_item,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_block_call_get_secret_configuration (
    UDisksBlock *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_block_call_get_secret_configuration_finish (
    UDisksBlock *proxy,
    GVariant **out_configuration,
    GAsyncResult *res,
    GError **error);

gboolean udisks_block_call_get_secret_configuration_sync (
    UDisksBlock *proxy,
    GVariant *arg_options,
    GVariant **out_configuration,
    GCancellable *cancellable,
    GError **error);

void udisks_block_call_format (
    UDisksBlock *proxy,
    const gchar *arg_type,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_block_call_format_finish (
    UDisksBlock *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_block_call_format_sync (
    UDisksBlock *proxy,
    const gchar *arg_type,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_block_call_open_for_backup (
    UDisksBlock *proxy,
    GVariant *arg_options,
    GUnixFDList *fd_list,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_block_call_open_for_backup_finish (
    UDisksBlock *proxy,
    GVariant **out_fd,
    GUnixFDList **out_fd_list,
    GAsyncResult *res,
    GError **error);

gboolean udisks_block_call_open_for_backup_sync (
    UDisksBlock *proxy,
    GVariant *arg_options,
    GUnixFDList  *fd_list,
    GVariant **out_fd,
    GUnixFDList **out_fd_list,
    GCancellable *cancellable,
    GError **error);

void udisks_block_call_open_for_restore (
    UDisksBlock *proxy,
    GVariant *arg_options,
    GUnixFDList *fd_list,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_block_call_open_for_restore_finish (
    UDisksBlock *proxy,
    GVariant **out_fd,
    GUnixFDList **out_fd_list,
    GAsyncResult *res,
    GError **error);

gboolean udisks_block_call_open_for_restore_sync (
    UDisksBlock *proxy,
    GVariant *arg_options,
    GUnixFDList  *fd_list,
    GVariant **out_fd,
    GUnixFDList **out_fd_list,
    GCancellable *cancellable,
    GError **error);

void udisks_block_call_open_for_benchmark (
    UDisksBlock *proxy,
    GVariant *arg_options,
    GUnixFDList *fd_list,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_block_call_open_for_benchmark_finish (
    UDisksBlock *proxy,
    GVariant **out_fd,
    GUnixFDList **out_fd_list,
    GAsyncResult *res,
    GError **error);

gboolean udisks_block_call_open_for_benchmark_sync (
    UDisksBlock *proxy,
    GVariant *arg_options,
    GUnixFDList  *fd_list,
    GVariant **out_fd,
    GUnixFDList **out_fd_list,
    GCancellable *cancellable,
    GError **error);

void udisks_block_call_open_device (
    UDisksBlock *proxy,
    const gchar *arg_mode,
    GVariant *arg_options,
    GUnixFDList *fd_list,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_block_call_open_device_finish (
    UDisksBlock *proxy,
    GVariant **out_fd,
    GUnixFDList **out_fd_list,
    GAsyncResult *res,
    GError **error);

gboolean udisks_block_call_open_device_sync (
    UDisksBlock *proxy,
    const gchar *arg_mode,
    GVariant *arg_options,
    GUnixFDList  *fd_list,
    GVariant **out_fd,
    GUnixFDList **out_fd_list,
    GCancellable *cancellable,
    GError **error);

void udisks_block_call_rescan (
    UDisksBlock *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_block_call_rescan_finish (
    UDisksBlock *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_block_call_rescan_sync (
    UDisksBlock *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
const gchar *udisks_block_get_device (UDisksBlock *object);
gchar *udisks_block_dup_device (UDisksBlock *object);
void udisks_block_set_device (UDisksBlock *object, const gchar *value);

const gchar *udisks_block_get_preferred_device (UDisksBlock *object);
gchar *udisks_block_dup_preferred_device (UDisksBlock *object);
void udisks_block_set_preferred_device (UDisksBlock *object, const gchar *value);

const gchar *const *udisks_block_get_symlinks (UDisksBlock *object);
gchar **udisks_block_dup_symlinks (UDisksBlock *object);
void udisks_block_set_symlinks (UDisksBlock *object, const gchar *const *value);

guint64 udisks_block_get_device_number (UDisksBlock *object);
void udisks_block_set_device_number (UDisksBlock *object, guint64 value);

const gchar *udisks_block_get_id (UDisksBlock *object);
gchar *udisks_block_dup_id (UDisksBlock *object);
void udisks_block_set_id (UDisksBlock *object, const gchar *value);

guint64 udisks_block_get_size (UDisksBlock *object);
void udisks_block_set_size (UDisksBlock *object, guint64 value);

gboolean udisks_block_get_read_only (UDisksBlock *object);
void udisks_block_set_read_only (UDisksBlock *object, gboolean value);

const gchar *udisks_block_get_drive (UDisksBlock *object);
gchar *udisks_block_dup_drive (UDisksBlock *object);
void udisks_block_set_drive (UDisksBlock *object, const gchar *value);

const gchar *udisks_block_get_mdraid (UDisksBlock *object);
gchar *udisks_block_dup_mdraid (UDisksBlock *object);
void udisks_block_set_mdraid (UDisksBlock *object, const gchar *value);

const gchar *udisks_block_get_mdraid_member (UDisksBlock *object);
gchar *udisks_block_dup_mdraid_member (UDisksBlock *object);
void udisks_block_set_mdraid_member (UDisksBlock *object, const gchar *value);

const gchar *udisks_block_get_id_usage (UDisksBlock *object);
gchar *udisks_block_dup_id_usage (UDisksBlock *object);
void udisks_block_set_id_usage (UDisksBlock *object, const gchar *value);

const gchar *udisks_block_get_id_type (UDisksBlock *object);
gchar *udisks_block_dup_id_type (UDisksBlock *object);
void udisks_block_set_id_type (UDisksBlock *object, const gchar *value);

const gchar *udisks_block_get_id_version (UDisksBlock *object);
gchar *udisks_block_dup_id_version (UDisksBlock *object);
void udisks_block_set_id_version (UDisksBlock *object, const gchar *value);

const gchar *udisks_block_get_id_label (UDisksBlock *object);
gchar *udisks_block_dup_id_label (UDisksBlock *object);
void udisks_block_set_id_label (UDisksBlock *object, const gchar *value);

const gchar *udisks_block_get_id_uuid (UDisksBlock *object);
gchar *udisks_block_dup_id_uuid (UDisksBlock *object);
void udisks_block_set_id_uuid (UDisksBlock *object, const gchar *value);

GVariant *udisks_block_get_configuration (UDisksBlock *object);
GVariant *udisks_block_dup_configuration (UDisksBlock *object);
void udisks_block_set_configuration (UDisksBlock *object, GVariant *value);

const gchar *udisks_block_get_crypto_backing_device (UDisksBlock *object);
gchar *udisks_block_dup_crypto_backing_device (UDisksBlock *object);
void udisks_block_set_crypto_backing_device (UDisksBlock *object, const gchar *value);

gboolean udisks_block_get_hint_partitionable (UDisksBlock *object);
void udisks_block_set_hint_partitionable (UDisksBlock *object, gboolean value);

gboolean udisks_block_get_hint_system (UDisksBlock *object);
void udisks_block_set_hint_system (UDisksBlock *object, gboolean value);

gboolean udisks_block_get_hint_ignore (UDisksBlock *object);
void udisks_block_set_hint_ignore (UDisksBlock *object, gboolean value);

gboolean udisks_block_get_hint_auto (UDisksBlock *object);
void udisks_block_set_hint_auto (UDisksBlock *object, gboolean value);

const gchar *udisks_block_get_hint_name (UDisksBlock *object);
gchar *udisks_block_dup_hint_name (UDisksBlock *object);
void udisks_block_set_hint_name (UDisksBlock *object, const gchar *value);

const gchar *udisks_block_get_hint_icon_name (UDisksBlock *object);
gchar *udisks_block_dup_hint_icon_name (UDisksBlock *object);
void udisks_block_set_hint_icon_name (UDisksBlock *object, const gchar *value);

const gchar *udisks_block_get_hint_symbolic_icon_name (UDisksBlock *object);
gchar *udisks_block_dup_hint_symbolic_icon_name (UDisksBlock *object);
void udisks_block_set_hint_symbolic_icon_name (UDisksBlock *object, const gchar *value);

const gchar *const *udisks_block_get_userspace_mount_options (UDisksBlock *object);
gchar **udisks_block_dup_userspace_mount_options (UDisksBlock *object);
void udisks_block_set_userspace_mount_options (UDisksBlock *object, const gchar *const *value);


/* ---- */

#define UDISKS_TYPE_BLOCK_PROXY (udisks_block_proxy_get_type ())
#define UDISKS_BLOCK_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_BLOCK_PROXY, UDisksBlockProxy))
#define UDISKS_BLOCK_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_BLOCK_PROXY, UDisksBlockProxyClass))
#define UDISKS_BLOCK_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_BLOCK_PROXY, UDisksBlockProxyClass))
#define UDISKS_IS_BLOCK_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_BLOCK_PROXY))
#define UDISKS_IS_BLOCK_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_BLOCK_PROXY))

typedef struct _UDisksBlockProxy UDisksBlockProxy;
typedef struct _UDisksBlockProxyClass UDisksBlockProxyClass;
typedef struct _UDisksBlockProxyPrivate UDisksBlockProxyPrivate;

struct _UDisksBlockProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksBlockProxyPrivate *priv;
};

struct _UDisksBlockProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_block_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksBlockProxy, g_object_unref)
#endif

void udisks_block_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksBlock *udisks_block_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksBlock *udisks_block_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_block_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksBlock *udisks_block_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksBlock *udisks_block_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_BLOCK_SKELETON (udisks_block_skeleton_get_type ())
#define UDISKS_BLOCK_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_BLOCK_SKELETON, UDisksBlockSkeleton))
#define UDISKS_BLOCK_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_BLOCK_SKELETON, UDisksBlockSkeletonClass))
#define UDISKS_BLOCK_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_BLOCK_SKELETON, UDisksBlockSkeletonClass))
#define UDISKS_IS_BLOCK_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_BLOCK_SKELETON))
#define UDISKS_IS_BLOCK_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_BLOCK_SKELETON))

typedef struct _UDisksBlockSkeleton UDisksBlockSkeleton;
typedef struct _UDisksBlockSkeletonClass UDisksBlockSkeletonClass;
typedef struct _UDisksBlockSkeletonPrivate UDisksBlockSkeletonPrivate;

struct _UDisksBlockSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksBlockSkeletonPrivate *priv;
};

struct _UDisksBlockSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_block_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksBlockSkeleton, g_object_unref)
#endif

UDisksBlock *udisks_block_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.PartitionTable */

#define UDISKS_TYPE_PARTITION_TABLE (udisks_partition_table_get_type ())
#define UDISKS_PARTITION_TABLE(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_PARTITION_TABLE, UDisksPartitionTable))
#define UDISKS_IS_PARTITION_TABLE(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_PARTITION_TABLE))
#define UDISKS_PARTITION_TABLE_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_PARTITION_TABLE, UDisksPartitionTableIface))

struct _UDisksPartitionTable;
typedef struct _UDisksPartitionTable UDisksPartitionTable;
typedef struct _UDisksPartitionTableIface UDisksPartitionTableIface;

struct _UDisksPartitionTableIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_create_partition) (
    UDisksPartitionTable *object,
    GDBusMethodInvocation *invocation,
    guint64 arg_offset,
    guint64 arg_size,
    const gchar *arg_type,
    const gchar *arg_name,
    GVariant *arg_options);

  gboolean (*handle_create_partition_and_format) (
    UDisksPartitionTable *object,
    GDBusMethodInvocation *invocation,
    guint64 arg_offset,
    guint64 arg_size,
    const gchar *arg_type,
    const gchar *arg_name,
    GVariant *arg_options,
    const gchar *arg_format_type,
    GVariant *arg_format_options);

  const gchar *const * (*get_partitions) (UDisksPartitionTable *object);

  const gchar * (*get_type_) (UDisksPartitionTable *object);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksPartitionTable, g_object_unref)
#endif

GType udisks_partition_table_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_partition_table_interface_info (void);
guint udisks_partition_table_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_partition_table_complete_create_partition (
    UDisksPartitionTable *object,
    GDBusMethodInvocation *invocation,
    const gchar *created_partition);

void udisks_partition_table_complete_create_partition_and_format (
    UDisksPartitionTable *object,
    GDBusMethodInvocation *invocation,
    const gchar *created_partition);



/* D-Bus method calls: */
void udisks_partition_table_call_create_partition (
    UDisksPartitionTable *proxy,
    guint64 arg_offset,
    guint64 arg_size,
    const gchar *arg_type,
    const gchar *arg_name,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_partition_table_call_create_partition_finish (
    UDisksPartitionTable *proxy,
    gchar **out_created_partition,
    GAsyncResult *res,
    GError **error);

gboolean udisks_partition_table_call_create_partition_sync (
    UDisksPartitionTable *proxy,
    guint64 arg_offset,
    guint64 arg_size,
    const gchar *arg_type,
    const gchar *arg_name,
    GVariant *arg_options,
    gchar **out_created_partition,
    GCancellable *cancellable,
    GError **error);

void udisks_partition_table_call_create_partition_and_format (
    UDisksPartitionTable *proxy,
    guint64 arg_offset,
    guint64 arg_size,
    const gchar *arg_type,
    const gchar *arg_name,
    GVariant *arg_options,
    const gchar *arg_format_type,
    GVariant *arg_format_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_partition_table_call_create_partition_and_format_finish (
    UDisksPartitionTable *proxy,
    gchar **out_created_partition,
    GAsyncResult *res,
    GError **error);

gboolean udisks_partition_table_call_create_partition_and_format_sync (
    UDisksPartitionTable *proxy,
    guint64 arg_offset,
    guint64 arg_size,
    const gchar *arg_type,
    const gchar *arg_name,
    GVariant *arg_options,
    const gchar *arg_format_type,
    GVariant *arg_format_options,
    gchar **out_created_partition,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
const gchar *const *udisks_partition_table_get_partitions (UDisksPartitionTable *object);
gchar **udisks_partition_table_dup_partitions (UDisksPartitionTable *object);
void udisks_partition_table_set_partitions (UDisksPartitionTable *object, const gchar *const *value);

const gchar *udisks_partition_table_get_type_ (UDisksPartitionTable *object);
gchar *udisks_partition_table_dup_type_ (UDisksPartitionTable *object);
void udisks_partition_table_set_type_ (UDisksPartitionTable *object, const gchar *value);


/* ---- */

#define UDISKS_TYPE_PARTITION_TABLE_PROXY (udisks_partition_table_proxy_get_type ())
#define UDISKS_PARTITION_TABLE_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_PARTITION_TABLE_PROXY, UDisksPartitionTableProxy))
#define UDISKS_PARTITION_TABLE_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_PARTITION_TABLE_PROXY, UDisksPartitionTableProxyClass))
#define UDISKS_PARTITION_TABLE_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_PARTITION_TABLE_PROXY, UDisksPartitionTableProxyClass))
#define UDISKS_IS_PARTITION_TABLE_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_PARTITION_TABLE_PROXY))
#define UDISKS_IS_PARTITION_TABLE_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_PARTITION_TABLE_PROXY))

typedef struct _UDisksPartitionTableProxy UDisksPartitionTableProxy;
typedef struct _UDisksPartitionTableProxyClass UDisksPartitionTableProxyClass;
typedef struct _UDisksPartitionTableProxyPrivate UDisksPartitionTableProxyPrivate;

struct _UDisksPartitionTableProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksPartitionTableProxyPrivate *priv;
};

struct _UDisksPartitionTableProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_partition_table_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksPartitionTableProxy, g_object_unref)
#endif

void udisks_partition_table_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksPartitionTable *udisks_partition_table_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksPartitionTable *udisks_partition_table_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_partition_table_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksPartitionTable *udisks_partition_table_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksPartitionTable *udisks_partition_table_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_PARTITION_TABLE_SKELETON (udisks_partition_table_skeleton_get_type ())
#define UDISKS_PARTITION_TABLE_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_PARTITION_TABLE_SKELETON, UDisksPartitionTableSkeleton))
#define UDISKS_PARTITION_TABLE_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_PARTITION_TABLE_SKELETON, UDisksPartitionTableSkeletonClass))
#define UDISKS_PARTITION_TABLE_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_PARTITION_TABLE_SKELETON, UDisksPartitionTableSkeletonClass))
#define UDISKS_IS_PARTITION_TABLE_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_PARTITION_TABLE_SKELETON))
#define UDISKS_IS_PARTITION_TABLE_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_PARTITION_TABLE_SKELETON))

typedef struct _UDisksPartitionTableSkeleton UDisksPartitionTableSkeleton;
typedef struct _UDisksPartitionTableSkeletonClass UDisksPartitionTableSkeletonClass;
typedef struct _UDisksPartitionTableSkeletonPrivate UDisksPartitionTableSkeletonPrivate;

struct _UDisksPartitionTableSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksPartitionTableSkeletonPrivate *priv;
};

struct _UDisksPartitionTableSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_partition_table_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksPartitionTableSkeleton, g_object_unref)
#endif

UDisksPartitionTable *udisks_partition_table_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Partition */

#define UDISKS_TYPE_PARTITION (udisks_partition_get_type ())
#define UDISKS_PARTITION(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_PARTITION, UDisksPartition))
#define UDISKS_IS_PARTITION(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_PARTITION))
#define UDISKS_PARTITION_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_PARTITION, UDisksPartitionIface))

struct _UDisksPartition;
typedef struct _UDisksPartition UDisksPartition;
typedef struct _UDisksPartitionIface UDisksPartitionIface;

struct _UDisksPartitionIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_delete) (
    UDisksPartition *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_resize) (
    UDisksPartition *object,
    GDBusMethodInvocation *invocation,
    guint64 arg_size,
    GVariant *arg_options);

  gboolean (*handle_set_flags) (
    UDisksPartition *object,
    GDBusMethodInvocation *invocation,
    guint64 arg_flags,
    GVariant *arg_options);

  gboolean (*handle_set_name) (
    UDisksPartition *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_name,
    GVariant *arg_options);

  gboolean (*handle_set_type) (
    UDisksPartition *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_type,
    GVariant *arg_options);

  guint64  (*get_flags) (UDisksPartition *object);

  gboolean  (*get_is_contained) (UDisksPartition *object);

  gboolean  (*get_is_container) (UDisksPartition *object);

  const gchar * (*get_name) (UDisksPartition *object);

  guint  (*get_number) (UDisksPartition *object);

  guint64  (*get_offset) (UDisksPartition *object);

  guint64  (*get_size) (UDisksPartition *object);

  const gchar * (*get_table) (UDisksPartition *object);

  const gchar * (*get_type_) (UDisksPartition *object);

  const gchar * (*get_uuid) (UDisksPartition *object);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksPartition, g_object_unref)
#endif

GType udisks_partition_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_partition_interface_info (void);
guint udisks_partition_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_partition_complete_set_type (
    UDisksPartition *object,
    GDBusMethodInvocation *invocation);

void udisks_partition_complete_set_name (
    UDisksPartition *object,
    GDBusMethodInvocation *invocation);

void udisks_partition_complete_set_flags (
    UDisksPartition *object,
    GDBusMethodInvocation *invocation);

void udisks_partition_complete_resize (
    UDisksPartition *object,
    GDBusMethodInvocation *invocation);

void udisks_partition_complete_delete (
    UDisksPartition *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void udisks_partition_call_set_type (
    UDisksPartition *proxy,
    const gchar *arg_type,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_partition_call_set_type_finish (
    UDisksPartition *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_partition_call_set_type_sync (
    UDisksPartition *proxy,
    const gchar *arg_type,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_partition_call_set_name (
    UDisksPartition *proxy,
    const gchar *arg_name,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_partition_call_set_name_finish (
    UDisksPartition *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_partition_call_set_name_sync (
    UDisksPartition *proxy,
    const gchar *arg_name,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_partition_call_set_flags (
    UDisksPartition *proxy,
    guint64 arg_flags,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_partition_call_set_flags_finish (
    UDisksPartition *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_partition_call_set_flags_sync (
    UDisksPartition *proxy,
    guint64 arg_flags,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_partition_call_resize (
    UDisksPartition *proxy,
    guint64 arg_size,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_partition_call_resize_finish (
    UDisksPartition *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_partition_call_resize_sync (
    UDisksPartition *proxy,
    guint64 arg_size,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_partition_call_delete (
    UDisksPartition *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_partition_call_delete_finish (
    UDisksPartition *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_partition_call_delete_sync (
    UDisksPartition *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
guint udisks_partition_get_number (UDisksPartition *object);
void udisks_partition_set_number (UDisksPartition *object, guint value);

const gchar *udisks_partition_get_type_ (UDisksPartition *object);
gchar *udisks_partition_dup_type_ (UDisksPartition *object);
void udisks_partition_set_type_ (UDisksPartition *object, const gchar *value);

guint64 udisks_partition_get_flags (UDisksPartition *object);
void udisks_partition_set_flags (UDisksPartition *object, guint64 value);

guint64 udisks_partition_get_offset (UDisksPartition *object);
void udisks_partition_set_offset (UDisksPartition *object, guint64 value);

guint64 udisks_partition_get_size (UDisksPartition *object);
void udisks_partition_set_size (UDisksPartition *object, guint64 value);

const gchar *udisks_partition_get_name (UDisksPartition *object);
gchar *udisks_partition_dup_name (UDisksPartition *object);
void udisks_partition_set_name (UDisksPartition *object, const gchar *value);

const gchar *udisks_partition_get_uuid (UDisksPartition *object);
gchar *udisks_partition_dup_uuid (UDisksPartition *object);
void udisks_partition_set_uuid (UDisksPartition *object, const gchar *value);

const gchar *udisks_partition_get_table (UDisksPartition *object);
gchar *udisks_partition_dup_table (UDisksPartition *object);
void udisks_partition_set_table (UDisksPartition *object, const gchar *value);

gboolean udisks_partition_get_is_container (UDisksPartition *object);
void udisks_partition_set_is_container (UDisksPartition *object, gboolean value);

gboolean udisks_partition_get_is_contained (UDisksPartition *object);
void udisks_partition_set_is_contained (UDisksPartition *object, gboolean value);


/* ---- */

#define UDISKS_TYPE_PARTITION_PROXY (udisks_partition_proxy_get_type ())
#define UDISKS_PARTITION_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_PARTITION_PROXY, UDisksPartitionProxy))
#define UDISKS_PARTITION_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_PARTITION_PROXY, UDisksPartitionProxyClass))
#define UDISKS_PARTITION_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_PARTITION_PROXY, UDisksPartitionProxyClass))
#define UDISKS_IS_PARTITION_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_PARTITION_PROXY))
#define UDISKS_IS_PARTITION_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_PARTITION_PROXY))

typedef struct _UDisksPartitionProxy UDisksPartitionProxy;
typedef struct _UDisksPartitionProxyClass UDisksPartitionProxyClass;
typedef struct _UDisksPartitionProxyPrivate UDisksPartitionProxyPrivate;

struct _UDisksPartitionProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksPartitionProxyPrivate *priv;
};

struct _UDisksPartitionProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_partition_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksPartitionProxy, g_object_unref)
#endif

void udisks_partition_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksPartition *udisks_partition_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksPartition *udisks_partition_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_partition_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksPartition *udisks_partition_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksPartition *udisks_partition_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_PARTITION_SKELETON (udisks_partition_skeleton_get_type ())
#define UDISKS_PARTITION_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_PARTITION_SKELETON, UDisksPartitionSkeleton))
#define UDISKS_PARTITION_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_PARTITION_SKELETON, UDisksPartitionSkeletonClass))
#define UDISKS_PARTITION_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_PARTITION_SKELETON, UDisksPartitionSkeletonClass))
#define UDISKS_IS_PARTITION_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_PARTITION_SKELETON))
#define UDISKS_IS_PARTITION_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_PARTITION_SKELETON))

typedef struct _UDisksPartitionSkeleton UDisksPartitionSkeleton;
typedef struct _UDisksPartitionSkeletonClass UDisksPartitionSkeletonClass;
typedef struct _UDisksPartitionSkeletonPrivate UDisksPartitionSkeletonPrivate;

struct _UDisksPartitionSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksPartitionSkeletonPrivate *priv;
};

struct _UDisksPartitionSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_partition_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksPartitionSkeleton, g_object_unref)
#endif

UDisksPartition *udisks_partition_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Filesystem */

#define UDISKS_TYPE_FILESYSTEM (udisks_filesystem_get_type ())
#define UDISKS_FILESYSTEM(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_FILESYSTEM, UDisksFilesystem))
#define UDISKS_IS_FILESYSTEM(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_FILESYSTEM))
#define UDISKS_FILESYSTEM_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_FILESYSTEM, UDisksFilesystemIface))

struct _UDisksFilesystem;
typedef struct _UDisksFilesystem UDisksFilesystem;
typedef struct _UDisksFilesystemIface UDisksFilesystemIface;

struct _UDisksFilesystemIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_mount) (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_set_label) (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_label,
    GVariant *arg_options);

  gboolean (*handle_unmount) (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  const gchar *const * (*get_mount_points) (UDisksFilesystem *object);

  guint64  (*get_size) (UDisksFilesystem *object);

  gboolean (*handle_check) (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_repair) (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_resize) (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation,
    guint64 arg_size,
    GVariant *arg_options);

  gboolean (*handle_take_ownership) (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksFilesystem, g_object_unref)
#endif

GType udisks_filesystem_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_filesystem_interface_info (void);
guint udisks_filesystem_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_filesystem_complete_set_label (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation);

void udisks_filesystem_complete_mount (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation,
    const gchar *mount_path);

void udisks_filesystem_complete_unmount (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation);

void udisks_filesystem_complete_resize (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation);

void udisks_filesystem_complete_check (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation,
    gboolean consistent);

void udisks_filesystem_complete_repair (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation,
    gboolean repaired);

void udisks_filesystem_complete_take_ownership (
    UDisksFilesystem *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void udisks_filesystem_call_set_label (
    UDisksFilesystem *proxy,
    const gchar *arg_label,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_filesystem_call_set_label_finish (
    UDisksFilesystem *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_filesystem_call_set_label_sync (
    UDisksFilesystem *proxy,
    const gchar *arg_label,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_filesystem_call_mount (
    UDisksFilesystem *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_filesystem_call_mount_finish (
    UDisksFilesystem *proxy,
    gchar **out_mount_path,
    GAsyncResult *res,
    GError **error);

gboolean udisks_filesystem_call_mount_sync (
    UDisksFilesystem *proxy,
    GVariant *arg_options,
    gchar **out_mount_path,
    GCancellable *cancellable,
    GError **error);

void udisks_filesystem_call_unmount (
    UDisksFilesystem *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_filesystem_call_unmount_finish (
    UDisksFilesystem *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_filesystem_call_unmount_sync (
    UDisksFilesystem *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_filesystem_call_resize (
    UDisksFilesystem *proxy,
    guint64 arg_size,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_filesystem_call_resize_finish (
    UDisksFilesystem *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_filesystem_call_resize_sync (
    UDisksFilesystem *proxy,
    guint64 arg_size,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_filesystem_call_check (
    UDisksFilesystem *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_filesystem_call_check_finish (
    UDisksFilesystem *proxy,
    gboolean *out_consistent,
    GAsyncResult *res,
    GError **error);

gboolean udisks_filesystem_call_check_sync (
    UDisksFilesystem *proxy,
    GVariant *arg_options,
    gboolean *out_consistent,
    GCancellable *cancellable,
    GError **error);

void udisks_filesystem_call_repair (
    UDisksFilesystem *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_filesystem_call_repair_finish (
    UDisksFilesystem *proxy,
    gboolean *out_repaired,
    GAsyncResult *res,
    GError **error);

gboolean udisks_filesystem_call_repair_sync (
    UDisksFilesystem *proxy,
    GVariant *arg_options,
    gboolean *out_repaired,
    GCancellable *cancellable,
    GError **error);

void udisks_filesystem_call_take_ownership (
    UDisksFilesystem *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_filesystem_call_take_ownership_finish (
    UDisksFilesystem *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_filesystem_call_take_ownership_sync (
    UDisksFilesystem *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
const gchar *const *udisks_filesystem_get_mount_points (UDisksFilesystem *object);
gchar **udisks_filesystem_dup_mount_points (UDisksFilesystem *object);
void udisks_filesystem_set_mount_points (UDisksFilesystem *object, const gchar *const *value);

guint64 udisks_filesystem_get_size (UDisksFilesystem *object);
void udisks_filesystem_set_size (UDisksFilesystem *object, guint64 value);


/* ---- */

#define UDISKS_TYPE_FILESYSTEM_PROXY (udisks_filesystem_proxy_get_type ())
#define UDISKS_FILESYSTEM_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_FILESYSTEM_PROXY, UDisksFilesystemProxy))
#define UDISKS_FILESYSTEM_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_FILESYSTEM_PROXY, UDisksFilesystemProxyClass))
#define UDISKS_FILESYSTEM_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_FILESYSTEM_PROXY, UDisksFilesystemProxyClass))
#define UDISKS_IS_FILESYSTEM_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_FILESYSTEM_PROXY))
#define UDISKS_IS_FILESYSTEM_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_FILESYSTEM_PROXY))

typedef struct _UDisksFilesystemProxy UDisksFilesystemProxy;
typedef struct _UDisksFilesystemProxyClass UDisksFilesystemProxyClass;
typedef struct _UDisksFilesystemProxyPrivate UDisksFilesystemProxyPrivate;

struct _UDisksFilesystemProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksFilesystemProxyPrivate *priv;
};

struct _UDisksFilesystemProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_filesystem_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksFilesystemProxy, g_object_unref)
#endif

void udisks_filesystem_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksFilesystem *udisks_filesystem_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksFilesystem *udisks_filesystem_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_filesystem_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksFilesystem *udisks_filesystem_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksFilesystem *udisks_filesystem_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_FILESYSTEM_SKELETON (udisks_filesystem_skeleton_get_type ())
#define UDISKS_FILESYSTEM_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_FILESYSTEM_SKELETON, UDisksFilesystemSkeleton))
#define UDISKS_FILESYSTEM_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_FILESYSTEM_SKELETON, UDisksFilesystemSkeletonClass))
#define UDISKS_FILESYSTEM_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_FILESYSTEM_SKELETON, UDisksFilesystemSkeletonClass))
#define UDISKS_IS_FILESYSTEM_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_FILESYSTEM_SKELETON))
#define UDISKS_IS_FILESYSTEM_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_FILESYSTEM_SKELETON))

typedef struct _UDisksFilesystemSkeleton UDisksFilesystemSkeleton;
typedef struct _UDisksFilesystemSkeletonClass UDisksFilesystemSkeletonClass;
typedef struct _UDisksFilesystemSkeletonPrivate UDisksFilesystemSkeletonPrivate;

struct _UDisksFilesystemSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksFilesystemSkeletonPrivate *priv;
};

struct _UDisksFilesystemSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_filesystem_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksFilesystemSkeleton, g_object_unref)
#endif

UDisksFilesystem *udisks_filesystem_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Swapspace */

#define UDISKS_TYPE_SWAPSPACE (udisks_swapspace_get_type ())
#define UDISKS_SWAPSPACE(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_SWAPSPACE, UDisksSwapspace))
#define UDISKS_IS_SWAPSPACE(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_SWAPSPACE))
#define UDISKS_SWAPSPACE_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_SWAPSPACE, UDisksSwapspaceIface))

struct _UDisksSwapspace;
typedef struct _UDisksSwapspace UDisksSwapspace;
typedef struct _UDisksSwapspaceIface UDisksSwapspaceIface;

struct _UDisksSwapspaceIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_set_label) (
    UDisksSwapspace *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_label,
    GVariant *arg_options);

  gboolean (*handle_start) (
    UDisksSwapspace *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_stop) (
    UDisksSwapspace *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean  (*get_active) (UDisksSwapspace *object);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksSwapspace, g_object_unref)
#endif

GType udisks_swapspace_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_swapspace_interface_info (void);
guint udisks_swapspace_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_swapspace_complete_start (
    UDisksSwapspace *object,
    GDBusMethodInvocation *invocation);

void udisks_swapspace_complete_stop (
    UDisksSwapspace *object,
    GDBusMethodInvocation *invocation);

void udisks_swapspace_complete_set_label (
    UDisksSwapspace *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void udisks_swapspace_call_start (
    UDisksSwapspace *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_swapspace_call_start_finish (
    UDisksSwapspace *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_swapspace_call_start_sync (
    UDisksSwapspace *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_swapspace_call_stop (
    UDisksSwapspace *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_swapspace_call_stop_finish (
    UDisksSwapspace *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_swapspace_call_stop_sync (
    UDisksSwapspace *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_swapspace_call_set_label (
    UDisksSwapspace *proxy,
    const gchar *arg_label,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_swapspace_call_set_label_finish (
    UDisksSwapspace *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_swapspace_call_set_label_sync (
    UDisksSwapspace *proxy,
    const gchar *arg_label,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
gboolean udisks_swapspace_get_active (UDisksSwapspace *object);
void udisks_swapspace_set_active (UDisksSwapspace *object, gboolean value);


/* ---- */

#define UDISKS_TYPE_SWAPSPACE_PROXY (udisks_swapspace_proxy_get_type ())
#define UDISKS_SWAPSPACE_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_SWAPSPACE_PROXY, UDisksSwapspaceProxy))
#define UDISKS_SWAPSPACE_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_SWAPSPACE_PROXY, UDisksSwapspaceProxyClass))
#define UDISKS_SWAPSPACE_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_SWAPSPACE_PROXY, UDisksSwapspaceProxyClass))
#define UDISKS_IS_SWAPSPACE_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_SWAPSPACE_PROXY))
#define UDISKS_IS_SWAPSPACE_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_SWAPSPACE_PROXY))

typedef struct _UDisksSwapspaceProxy UDisksSwapspaceProxy;
typedef struct _UDisksSwapspaceProxyClass UDisksSwapspaceProxyClass;
typedef struct _UDisksSwapspaceProxyPrivate UDisksSwapspaceProxyPrivate;

struct _UDisksSwapspaceProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksSwapspaceProxyPrivate *priv;
};

struct _UDisksSwapspaceProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_swapspace_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksSwapspaceProxy, g_object_unref)
#endif

void udisks_swapspace_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksSwapspace *udisks_swapspace_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksSwapspace *udisks_swapspace_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_swapspace_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksSwapspace *udisks_swapspace_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksSwapspace *udisks_swapspace_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_SWAPSPACE_SKELETON (udisks_swapspace_skeleton_get_type ())
#define UDISKS_SWAPSPACE_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_SWAPSPACE_SKELETON, UDisksSwapspaceSkeleton))
#define UDISKS_SWAPSPACE_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_SWAPSPACE_SKELETON, UDisksSwapspaceSkeletonClass))
#define UDISKS_SWAPSPACE_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_SWAPSPACE_SKELETON, UDisksSwapspaceSkeletonClass))
#define UDISKS_IS_SWAPSPACE_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_SWAPSPACE_SKELETON))
#define UDISKS_IS_SWAPSPACE_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_SWAPSPACE_SKELETON))

typedef struct _UDisksSwapspaceSkeleton UDisksSwapspaceSkeleton;
typedef struct _UDisksSwapspaceSkeletonClass UDisksSwapspaceSkeletonClass;
typedef struct _UDisksSwapspaceSkeletonPrivate UDisksSwapspaceSkeletonPrivate;

struct _UDisksSwapspaceSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksSwapspaceSkeletonPrivate *priv;
};

struct _UDisksSwapspaceSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_swapspace_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksSwapspaceSkeleton, g_object_unref)
#endif

UDisksSwapspace *udisks_swapspace_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Encrypted */

#define UDISKS_TYPE_ENCRYPTED (udisks_encrypted_get_type ())
#define UDISKS_ENCRYPTED(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_ENCRYPTED, UDisksEncrypted))
#define UDISKS_IS_ENCRYPTED(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_ENCRYPTED))
#define UDISKS_ENCRYPTED_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_ENCRYPTED, UDisksEncryptedIface))

struct _UDisksEncrypted;
typedef struct _UDisksEncrypted UDisksEncrypted;
typedef struct _UDisksEncryptedIface UDisksEncryptedIface;

struct _UDisksEncryptedIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_change_passphrase) (
    UDisksEncrypted *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_passphrase,
    const gchar *arg_new_passphrase,
    GVariant *arg_options);

  gboolean (*handle_lock) (
    UDisksEncrypted *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_unlock) (
    UDisksEncrypted *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_passphrase,
    GVariant *arg_options);

  GVariant * (*get_child_configuration) (UDisksEncrypted *object);

  const gchar * (*get_cleartext_device) (UDisksEncrypted *object);

  const gchar * (*get_hint_encryption_type) (UDisksEncrypted *object);

  guint64  (*get_metadata_size) (UDisksEncrypted *object);

  gboolean (*handle_resize) (
    UDisksEncrypted *object,
    GDBusMethodInvocation *invocation,
    guint64 arg_size,
    GVariant *arg_options);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksEncrypted, g_object_unref)
#endif

GType udisks_encrypted_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_encrypted_interface_info (void);
guint udisks_encrypted_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_encrypted_complete_unlock (
    UDisksEncrypted *object,
    GDBusMethodInvocation *invocation,
    const gchar *cleartext_device);

void udisks_encrypted_complete_lock (
    UDisksEncrypted *object,
    GDBusMethodInvocation *invocation);

void udisks_encrypted_complete_change_passphrase (
    UDisksEncrypted *object,
    GDBusMethodInvocation *invocation);

void udisks_encrypted_complete_resize (
    UDisksEncrypted *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void udisks_encrypted_call_unlock (
    UDisksEncrypted *proxy,
    const gchar *arg_passphrase,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_encrypted_call_unlock_finish (
    UDisksEncrypted *proxy,
    gchar **out_cleartext_device,
    GAsyncResult *res,
    GError **error);

gboolean udisks_encrypted_call_unlock_sync (
    UDisksEncrypted *proxy,
    const gchar *arg_passphrase,
    GVariant *arg_options,
    gchar **out_cleartext_device,
    GCancellable *cancellable,
    GError **error);

void udisks_encrypted_call_lock (
    UDisksEncrypted *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_encrypted_call_lock_finish (
    UDisksEncrypted *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_encrypted_call_lock_sync (
    UDisksEncrypted *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_encrypted_call_change_passphrase (
    UDisksEncrypted *proxy,
    const gchar *arg_passphrase,
    const gchar *arg_new_passphrase,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_encrypted_call_change_passphrase_finish (
    UDisksEncrypted *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_encrypted_call_change_passphrase_sync (
    UDisksEncrypted *proxy,
    const gchar *arg_passphrase,
    const gchar *arg_new_passphrase,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_encrypted_call_resize (
    UDisksEncrypted *proxy,
    guint64 arg_size,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_encrypted_call_resize_finish (
    UDisksEncrypted *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_encrypted_call_resize_sync (
    UDisksEncrypted *proxy,
    guint64 arg_size,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
GVariant *udisks_encrypted_get_child_configuration (UDisksEncrypted *object);
GVariant *udisks_encrypted_dup_child_configuration (UDisksEncrypted *object);
void udisks_encrypted_set_child_configuration (UDisksEncrypted *object, GVariant *value);

const gchar *udisks_encrypted_get_hint_encryption_type (UDisksEncrypted *object);
gchar *udisks_encrypted_dup_hint_encryption_type (UDisksEncrypted *object);
void udisks_encrypted_set_hint_encryption_type (UDisksEncrypted *object, const gchar *value);

guint64 udisks_encrypted_get_metadata_size (UDisksEncrypted *object);
void udisks_encrypted_set_metadata_size (UDisksEncrypted *object, guint64 value);

const gchar *udisks_encrypted_get_cleartext_device (UDisksEncrypted *object);
gchar *udisks_encrypted_dup_cleartext_device (UDisksEncrypted *object);
void udisks_encrypted_set_cleartext_device (UDisksEncrypted *object, const gchar *value);


/* ---- */

#define UDISKS_TYPE_ENCRYPTED_PROXY (udisks_encrypted_proxy_get_type ())
#define UDISKS_ENCRYPTED_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_ENCRYPTED_PROXY, UDisksEncryptedProxy))
#define UDISKS_ENCRYPTED_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_ENCRYPTED_PROXY, UDisksEncryptedProxyClass))
#define UDISKS_ENCRYPTED_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_ENCRYPTED_PROXY, UDisksEncryptedProxyClass))
#define UDISKS_IS_ENCRYPTED_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_ENCRYPTED_PROXY))
#define UDISKS_IS_ENCRYPTED_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_ENCRYPTED_PROXY))

typedef struct _UDisksEncryptedProxy UDisksEncryptedProxy;
typedef struct _UDisksEncryptedProxyClass UDisksEncryptedProxyClass;
typedef struct _UDisksEncryptedProxyPrivate UDisksEncryptedProxyPrivate;

struct _UDisksEncryptedProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksEncryptedProxyPrivate *priv;
};

struct _UDisksEncryptedProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_encrypted_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksEncryptedProxy, g_object_unref)
#endif

void udisks_encrypted_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksEncrypted *udisks_encrypted_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksEncrypted *udisks_encrypted_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_encrypted_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksEncrypted *udisks_encrypted_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksEncrypted *udisks_encrypted_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_ENCRYPTED_SKELETON (udisks_encrypted_skeleton_get_type ())
#define UDISKS_ENCRYPTED_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_ENCRYPTED_SKELETON, UDisksEncryptedSkeleton))
#define UDISKS_ENCRYPTED_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_ENCRYPTED_SKELETON, UDisksEncryptedSkeletonClass))
#define UDISKS_ENCRYPTED_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_ENCRYPTED_SKELETON, UDisksEncryptedSkeletonClass))
#define UDISKS_IS_ENCRYPTED_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_ENCRYPTED_SKELETON))
#define UDISKS_IS_ENCRYPTED_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_ENCRYPTED_SKELETON))

typedef struct _UDisksEncryptedSkeleton UDisksEncryptedSkeleton;
typedef struct _UDisksEncryptedSkeletonClass UDisksEncryptedSkeletonClass;
typedef struct _UDisksEncryptedSkeletonPrivate UDisksEncryptedSkeletonPrivate;

struct _UDisksEncryptedSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksEncryptedSkeletonPrivate *priv;
};

struct _UDisksEncryptedSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_encrypted_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksEncryptedSkeleton, g_object_unref)
#endif

UDisksEncrypted *udisks_encrypted_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Loop */

#define UDISKS_TYPE_LOOP (udisks_loop_get_type ())
#define UDISKS_LOOP(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_LOOP, UDisksLoop))
#define UDISKS_IS_LOOP(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_LOOP))
#define UDISKS_LOOP_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_LOOP, UDisksLoopIface))

struct _UDisksLoop;
typedef struct _UDisksLoop UDisksLoop;
typedef struct _UDisksLoopIface UDisksLoopIface;

struct _UDisksLoopIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_delete) (
    UDisksLoop *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_set_autoclear) (
    UDisksLoop *object,
    GDBusMethodInvocation *invocation,
    gboolean arg_value,
    GVariant *arg_options);

  gboolean  (*get_autoclear) (UDisksLoop *object);

  const gchar * (*get_backing_file) (UDisksLoop *object);

  guint  (*get_setup_by_uid) (UDisksLoop *object);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksLoop, g_object_unref)
#endif

GType udisks_loop_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_loop_interface_info (void);
guint udisks_loop_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_loop_complete_delete (
    UDisksLoop *object,
    GDBusMethodInvocation *invocation);

void udisks_loop_complete_set_autoclear (
    UDisksLoop *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void udisks_loop_call_delete (
    UDisksLoop *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_loop_call_delete_finish (
    UDisksLoop *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_loop_call_delete_sync (
    UDisksLoop *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_loop_call_set_autoclear (
    UDisksLoop *proxy,
    gboolean arg_value,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_loop_call_set_autoclear_finish (
    UDisksLoop *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_loop_call_set_autoclear_sync (
    UDisksLoop *proxy,
    gboolean arg_value,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
const gchar *udisks_loop_get_backing_file (UDisksLoop *object);
gchar *udisks_loop_dup_backing_file (UDisksLoop *object);
void udisks_loop_set_backing_file (UDisksLoop *object, const gchar *value);

gboolean udisks_loop_get_autoclear (UDisksLoop *object);
void udisks_loop_set_autoclear (UDisksLoop *object, gboolean value);

guint udisks_loop_get_setup_by_uid (UDisksLoop *object);
void udisks_loop_set_setup_by_uid (UDisksLoop *object, guint value);


/* ---- */

#define UDISKS_TYPE_LOOP_PROXY (udisks_loop_proxy_get_type ())
#define UDISKS_LOOP_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_LOOP_PROXY, UDisksLoopProxy))
#define UDISKS_LOOP_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_LOOP_PROXY, UDisksLoopProxyClass))
#define UDISKS_LOOP_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_LOOP_PROXY, UDisksLoopProxyClass))
#define UDISKS_IS_LOOP_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_LOOP_PROXY))
#define UDISKS_IS_LOOP_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_LOOP_PROXY))

typedef struct _UDisksLoopProxy UDisksLoopProxy;
typedef struct _UDisksLoopProxyClass UDisksLoopProxyClass;
typedef struct _UDisksLoopProxyPrivate UDisksLoopProxyPrivate;

struct _UDisksLoopProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksLoopProxyPrivate *priv;
};

struct _UDisksLoopProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_loop_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksLoopProxy, g_object_unref)
#endif

void udisks_loop_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksLoop *udisks_loop_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksLoop *udisks_loop_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_loop_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksLoop *udisks_loop_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksLoop *udisks_loop_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_LOOP_SKELETON (udisks_loop_skeleton_get_type ())
#define UDISKS_LOOP_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_LOOP_SKELETON, UDisksLoopSkeleton))
#define UDISKS_LOOP_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_LOOP_SKELETON, UDisksLoopSkeletonClass))
#define UDISKS_LOOP_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_LOOP_SKELETON, UDisksLoopSkeletonClass))
#define UDISKS_IS_LOOP_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_LOOP_SKELETON))
#define UDISKS_IS_LOOP_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_LOOP_SKELETON))

typedef struct _UDisksLoopSkeleton UDisksLoopSkeleton;
typedef struct _UDisksLoopSkeletonClass UDisksLoopSkeletonClass;
typedef struct _UDisksLoopSkeletonPrivate UDisksLoopSkeletonPrivate;

struct _UDisksLoopSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksLoopSkeletonPrivate *priv;
};

struct _UDisksLoopSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_loop_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksLoopSkeleton, g_object_unref)
#endif

UDisksLoop *udisks_loop_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.MDRaid */

#define UDISKS_TYPE_MDRAID (udisks_mdraid_get_type ())
#define UDISKS_MDRAID(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_MDRAID, UDisksMDRaid))
#define UDISKS_IS_MDRAID(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_MDRAID))
#define UDISKS_MDRAID_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_MDRAID, UDisksMDRaidIface))

struct _UDisksMDRaid;
typedef struct _UDisksMDRaid UDisksMDRaid;
typedef struct _UDisksMDRaidIface UDisksMDRaidIface;

struct _UDisksMDRaidIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_add_device) (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_device,
    GVariant *arg_options);

  gboolean (*handle_delete) (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_remove_device) (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_device,
    GVariant *arg_options);

  gboolean (*handle_request_sync_action) (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_sync_action,
    GVariant *arg_options);

  gboolean (*handle_set_bitmap_location) (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_value,
    GVariant *arg_options);

  gboolean (*handle_start) (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_stop) (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  GVariant * (*get_active_devices) (UDisksMDRaid *object);

  const gchar * (*get_bitmap_location) (UDisksMDRaid *object);

  GVariant * (*get_child_configuration) (UDisksMDRaid *object);

  guint64  (*get_chunk_size) (UDisksMDRaid *object);

  guint  (*get_degraded) (UDisksMDRaid *object);

  const gchar * (*get_level) (UDisksMDRaid *object);

  const gchar * (*get_name) (UDisksMDRaid *object);

  guint  (*get_num_devices) (UDisksMDRaid *object);

  gboolean  (*get_running) (UDisksMDRaid *object);

  guint64  (*get_size) (UDisksMDRaid *object);

  const gchar * (*get_sync_action) (UDisksMDRaid *object);

  gdouble  (*get_sync_completed) (UDisksMDRaid *object);

  guint64  (*get_sync_rate) (UDisksMDRaid *object);

  guint64  (*get_sync_remaining_time) (UDisksMDRaid *object);

  const gchar * (*get_uuid) (UDisksMDRaid *object);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksMDRaid, g_object_unref)
#endif

GType udisks_mdraid_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_mdraid_interface_info (void);
guint udisks_mdraid_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_mdraid_complete_start (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation);

void udisks_mdraid_complete_stop (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation);

void udisks_mdraid_complete_remove_device (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation);

void udisks_mdraid_complete_add_device (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation);

void udisks_mdraid_complete_set_bitmap_location (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation);

void udisks_mdraid_complete_request_sync_action (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation);

void udisks_mdraid_complete_delete (
    UDisksMDRaid *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void udisks_mdraid_call_start (
    UDisksMDRaid *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_mdraid_call_start_finish (
    UDisksMDRaid *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_mdraid_call_start_sync (
    UDisksMDRaid *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_mdraid_call_stop (
    UDisksMDRaid *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_mdraid_call_stop_finish (
    UDisksMDRaid *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_mdraid_call_stop_sync (
    UDisksMDRaid *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_mdraid_call_remove_device (
    UDisksMDRaid *proxy,
    const gchar *arg_device,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_mdraid_call_remove_device_finish (
    UDisksMDRaid *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_mdraid_call_remove_device_sync (
    UDisksMDRaid *proxy,
    const gchar *arg_device,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_mdraid_call_add_device (
    UDisksMDRaid *proxy,
    const gchar *arg_device,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_mdraid_call_add_device_finish (
    UDisksMDRaid *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_mdraid_call_add_device_sync (
    UDisksMDRaid *proxy,
    const gchar *arg_device,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_mdraid_call_set_bitmap_location (
    UDisksMDRaid *proxy,
    const gchar *arg_value,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_mdraid_call_set_bitmap_location_finish (
    UDisksMDRaid *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_mdraid_call_set_bitmap_location_sync (
    UDisksMDRaid *proxy,
    const gchar *arg_value,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_mdraid_call_request_sync_action (
    UDisksMDRaid *proxy,
    const gchar *arg_sync_action,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_mdraid_call_request_sync_action_finish (
    UDisksMDRaid *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_mdraid_call_request_sync_action_sync (
    UDisksMDRaid *proxy,
    const gchar *arg_sync_action,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_mdraid_call_delete (
    UDisksMDRaid *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_mdraid_call_delete_finish (
    UDisksMDRaid *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_mdraid_call_delete_sync (
    UDisksMDRaid *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
const gchar *udisks_mdraid_get_uuid (UDisksMDRaid *object);
gchar *udisks_mdraid_dup_uuid (UDisksMDRaid *object);
void udisks_mdraid_set_uuid (UDisksMDRaid *object, const gchar *value);

const gchar *udisks_mdraid_get_name (UDisksMDRaid *object);
gchar *udisks_mdraid_dup_name (UDisksMDRaid *object);
void udisks_mdraid_set_name (UDisksMDRaid *object, const gchar *value);

const gchar *udisks_mdraid_get_level (UDisksMDRaid *object);
gchar *udisks_mdraid_dup_level (UDisksMDRaid *object);
void udisks_mdraid_set_level (UDisksMDRaid *object, const gchar *value);

guint udisks_mdraid_get_num_devices (UDisksMDRaid *object);
void udisks_mdraid_set_num_devices (UDisksMDRaid *object, guint value);

guint64 udisks_mdraid_get_size (UDisksMDRaid *object);
void udisks_mdraid_set_size (UDisksMDRaid *object, guint64 value);

const gchar *udisks_mdraid_get_sync_action (UDisksMDRaid *object);
gchar *udisks_mdraid_dup_sync_action (UDisksMDRaid *object);
void udisks_mdraid_set_sync_action (UDisksMDRaid *object, const gchar *value);

gdouble udisks_mdraid_get_sync_completed (UDisksMDRaid *object);
void udisks_mdraid_set_sync_completed (UDisksMDRaid *object, gdouble value);

guint64 udisks_mdraid_get_sync_rate (UDisksMDRaid *object);
void udisks_mdraid_set_sync_rate (UDisksMDRaid *object, guint64 value);

guint64 udisks_mdraid_get_sync_remaining_time (UDisksMDRaid *object);
void udisks_mdraid_set_sync_remaining_time (UDisksMDRaid *object, guint64 value);

guint udisks_mdraid_get_degraded (UDisksMDRaid *object);
void udisks_mdraid_set_degraded (UDisksMDRaid *object, guint value);

const gchar *udisks_mdraid_get_bitmap_location (UDisksMDRaid *object);
gchar *udisks_mdraid_dup_bitmap_location (UDisksMDRaid *object);
void udisks_mdraid_set_bitmap_location (UDisksMDRaid *object, const gchar *value);

guint64 udisks_mdraid_get_chunk_size (UDisksMDRaid *object);
void udisks_mdraid_set_chunk_size (UDisksMDRaid *object, guint64 value);

GVariant *udisks_mdraid_get_active_devices (UDisksMDRaid *object);
GVariant *udisks_mdraid_dup_active_devices (UDisksMDRaid *object);
void udisks_mdraid_set_active_devices (UDisksMDRaid *object, GVariant *value);

GVariant *udisks_mdraid_get_child_configuration (UDisksMDRaid *object);
GVariant *udisks_mdraid_dup_child_configuration (UDisksMDRaid *object);
void udisks_mdraid_set_child_configuration (UDisksMDRaid *object, GVariant *value);

gboolean udisks_mdraid_get_running (UDisksMDRaid *object);
void udisks_mdraid_set_running (UDisksMDRaid *object, gboolean value);


/* ---- */

#define UDISKS_TYPE_MDRAID_PROXY (udisks_mdraid_proxy_get_type ())
#define UDISKS_MDRAID_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_MDRAID_PROXY, UDisksMDRaidProxy))
#define UDISKS_MDRAID_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_MDRAID_PROXY, UDisksMDRaidProxyClass))
#define UDISKS_MDRAID_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_MDRAID_PROXY, UDisksMDRaidProxyClass))
#define UDISKS_IS_MDRAID_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_MDRAID_PROXY))
#define UDISKS_IS_MDRAID_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_MDRAID_PROXY))

typedef struct _UDisksMDRaidProxy UDisksMDRaidProxy;
typedef struct _UDisksMDRaidProxyClass UDisksMDRaidProxyClass;
typedef struct _UDisksMDRaidProxyPrivate UDisksMDRaidProxyPrivate;

struct _UDisksMDRaidProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksMDRaidProxyPrivate *priv;
};

struct _UDisksMDRaidProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_mdraid_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksMDRaidProxy, g_object_unref)
#endif

void udisks_mdraid_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksMDRaid *udisks_mdraid_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksMDRaid *udisks_mdraid_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_mdraid_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksMDRaid *udisks_mdraid_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksMDRaid *udisks_mdraid_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_MDRAID_SKELETON (udisks_mdraid_skeleton_get_type ())
#define UDISKS_MDRAID_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_MDRAID_SKELETON, UDisksMDRaidSkeleton))
#define UDISKS_MDRAID_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_MDRAID_SKELETON, UDisksMDRaidSkeletonClass))
#define UDISKS_MDRAID_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_MDRAID_SKELETON, UDisksMDRaidSkeletonClass))
#define UDISKS_IS_MDRAID_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_MDRAID_SKELETON))
#define UDISKS_IS_MDRAID_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_MDRAID_SKELETON))

typedef struct _UDisksMDRaidSkeleton UDisksMDRaidSkeleton;
typedef struct _UDisksMDRaidSkeletonClass UDisksMDRaidSkeletonClass;
typedef struct _UDisksMDRaidSkeletonPrivate UDisksMDRaidSkeletonPrivate;

struct _UDisksMDRaidSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksMDRaidSkeletonPrivate *priv;
};

struct _UDisksMDRaidSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_mdraid_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksMDRaidSkeleton, g_object_unref)
#endif

UDisksMDRaid *udisks_mdraid_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Job */

#define UDISKS_TYPE_JOB (udisks_job_get_type ())
#define UDISKS_JOB(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_JOB, UDisksJob))
#define UDISKS_IS_JOB(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_JOB))
#define UDISKS_JOB_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_JOB, UDisksJobIface))

struct _UDisksJob;
typedef struct _UDisksJob UDisksJob;
typedef struct _UDisksJobIface UDisksJobIface;

struct _UDisksJobIface
{
  GTypeInterface parent_iface;



  gboolean (*handle_cancel) (
    UDisksJob *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean  (*get_cancelable) (UDisksJob *object);

  guint64  (*get_expected_end_time) (UDisksJob *object);

  const gchar *const * (*get_objects) (UDisksJob *object);

  const gchar * (*get_operation) (UDisksJob *object);

  gdouble  (*get_progress) (UDisksJob *object);

  gboolean  (*get_progress_valid) (UDisksJob *object);

  guint64  (*get_start_time) (UDisksJob *object);

  guint  (*get_started_by_uid) (UDisksJob *object);

  void (*completed) (
    UDisksJob *object,
    gboolean arg_success,
    const gchar *arg_message);

  guint64  (*get_bytes) (UDisksJob *object);

  guint64  (*get_rate) (UDisksJob *object);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksJob, g_object_unref)
#endif

GType udisks_job_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_job_interface_info (void);
guint udisks_job_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_job_complete_cancel (
    UDisksJob *object,
    GDBusMethodInvocation *invocation);



/* D-Bus signal emissions functions: */
void udisks_job_emit_completed (
    UDisksJob *object,
    gboolean arg_success,
    const gchar *arg_message);



/* D-Bus method calls: */
void udisks_job_call_cancel (
    UDisksJob *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_job_call_cancel_finish (
    UDisksJob *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_job_call_cancel_sync (
    UDisksJob *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
const gchar *udisks_job_get_operation (UDisksJob *object);
gchar *udisks_job_dup_operation (UDisksJob *object);
void udisks_job_set_operation (UDisksJob *object, const gchar *value);

gdouble udisks_job_get_progress (UDisksJob *object);
void udisks_job_set_progress (UDisksJob *object, gdouble value);

gboolean udisks_job_get_progress_valid (UDisksJob *object);
void udisks_job_set_progress_valid (UDisksJob *object, gboolean value);

guint64 udisks_job_get_bytes (UDisksJob *object);
void udisks_job_set_bytes (UDisksJob *object, guint64 value);

guint64 udisks_job_get_rate (UDisksJob *object);
void udisks_job_set_rate (UDisksJob *object, guint64 value);

guint64 udisks_job_get_start_time (UDisksJob *object);
void udisks_job_set_start_time (UDisksJob *object, guint64 value);

guint64 udisks_job_get_expected_end_time (UDisksJob *object);
void udisks_job_set_expected_end_time (UDisksJob *object, guint64 value);

const gchar *const *udisks_job_get_objects (UDisksJob *object);
gchar **udisks_job_dup_objects (UDisksJob *object);
void udisks_job_set_objects (UDisksJob *object, const gchar *const *value);

guint udisks_job_get_started_by_uid (UDisksJob *object);
void udisks_job_set_started_by_uid (UDisksJob *object, guint value);

gboolean udisks_job_get_cancelable (UDisksJob *object);
void udisks_job_set_cancelable (UDisksJob *object, gboolean value);


/* ---- */

#define UDISKS_TYPE_JOB_PROXY (udisks_job_proxy_get_type ())
#define UDISKS_JOB_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_JOB_PROXY, UDisksJobProxy))
#define UDISKS_JOB_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_JOB_PROXY, UDisksJobProxyClass))
#define UDISKS_JOB_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_JOB_PROXY, UDisksJobProxyClass))
#define UDISKS_IS_JOB_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_JOB_PROXY))
#define UDISKS_IS_JOB_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_JOB_PROXY))

typedef struct _UDisksJobProxy UDisksJobProxy;
typedef struct _UDisksJobProxyClass UDisksJobProxyClass;
typedef struct _UDisksJobProxyPrivate UDisksJobProxyPrivate;

struct _UDisksJobProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksJobProxyPrivate *priv;
};

struct _UDisksJobProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_job_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksJobProxy, g_object_unref)
#endif

void udisks_job_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksJob *udisks_job_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksJob *udisks_job_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_job_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksJob *udisks_job_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksJob *udisks_job_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_JOB_SKELETON (udisks_job_skeleton_get_type ())
#define UDISKS_JOB_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_JOB_SKELETON, UDisksJobSkeleton))
#define UDISKS_JOB_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_JOB_SKELETON, UDisksJobSkeletonClass))
#define UDISKS_JOB_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_JOB_SKELETON, UDisksJobSkeletonClass))
#define UDISKS_IS_JOB_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_JOB_SKELETON))
#define UDISKS_IS_JOB_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_JOB_SKELETON))

typedef struct _UDisksJobSkeleton UDisksJobSkeleton;
typedef struct _UDisksJobSkeletonClass UDisksJobSkeletonClass;
typedef struct _UDisksJobSkeletonPrivate UDisksJobSkeletonPrivate;

struct _UDisksJobSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksJobSkeletonPrivate *priv;
};

struct _UDisksJobSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_job_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksJobSkeleton, g_object_unref)
#endif

UDisksJob *udisks_job_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Manager.Bcache */

#define UDISKS_TYPE_MANAGER_BCACHE (udisks_manager_bcache_get_type ())
#define UDISKS_MANAGER_BCACHE(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_MANAGER_BCACHE, UDisksManagerBcache))
#define UDISKS_IS_MANAGER_BCACHE(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_MANAGER_BCACHE))
#define UDISKS_MANAGER_BCACHE_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_MANAGER_BCACHE, UDisksManagerBcacheIface))

struct _UDisksManagerBcache;
typedef struct _UDisksManagerBcache UDisksManagerBcache;
typedef struct _UDisksManagerBcacheIface UDisksManagerBcacheIface;

struct _UDisksManagerBcacheIface
{
  GTypeInterface parent_iface;

  gboolean (*handle_bcache_create) (
    UDisksManagerBcache *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_backing_dev,
    const gchar *arg_cache_dev,
    GVariant *arg_options);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksManagerBcache, g_object_unref)
#endif

GType udisks_manager_bcache_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_manager_bcache_interface_info (void);
guint udisks_manager_bcache_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_manager_bcache_complete_bcache_create (
    UDisksManagerBcache *object,
    GDBusMethodInvocation *invocation,
    const gchar *bcache);



/* D-Bus method calls: */
void udisks_manager_bcache_call_bcache_create (
    UDisksManagerBcache *proxy,
    const gchar *arg_backing_dev,
    const gchar *arg_cache_dev,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_manager_bcache_call_bcache_create_finish (
    UDisksManagerBcache *proxy,
    gchar **out_bcache,
    GAsyncResult *res,
    GError **error);

gboolean udisks_manager_bcache_call_bcache_create_sync (
    UDisksManagerBcache *proxy,
    const gchar *arg_backing_dev,
    const gchar *arg_cache_dev,
    GVariant *arg_options,
    gchar **out_bcache,
    GCancellable *cancellable,
    GError **error);



/* ---- */

#define UDISKS_TYPE_MANAGER_BCACHE_PROXY (udisks_manager_bcache_proxy_get_type ())
#define UDISKS_MANAGER_BCACHE_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_MANAGER_BCACHE_PROXY, UDisksManagerBcacheProxy))
#define UDISKS_MANAGER_BCACHE_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_MANAGER_BCACHE_PROXY, UDisksManagerBcacheProxyClass))
#define UDISKS_MANAGER_BCACHE_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_MANAGER_BCACHE_PROXY, UDisksManagerBcacheProxyClass))
#define UDISKS_IS_MANAGER_BCACHE_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_MANAGER_BCACHE_PROXY))
#define UDISKS_IS_MANAGER_BCACHE_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_MANAGER_BCACHE_PROXY))

typedef struct _UDisksManagerBcacheProxy UDisksManagerBcacheProxy;
typedef struct _UDisksManagerBcacheProxyClass UDisksManagerBcacheProxyClass;
typedef struct _UDisksManagerBcacheProxyPrivate UDisksManagerBcacheProxyPrivate;

struct _UDisksManagerBcacheProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksManagerBcacheProxyPrivate *priv;
};

struct _UDisksManagerBcacheProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_manager_bcache_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksManagerBcacheProxy, g_object_unref)
#endif

void udisks_manager_bcache_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksManagerBcache *udisks_manager_bcache_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksManagerBcache *udisks_manager_bcache_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_manager_bcache_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksManagerBcache *udisks_manager_bcache_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksManagerBcache *udisks_manager_bcache_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_MANAGER_BCACHE_SKELETON (udisks_manager_bcache_skeleton_get_type ())
#define UDISKS_MANAGER_BCACHE_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_MANAGER_BCACHE_SKELETON, UDisksManagerBcacheSkeleton))
#define UDISKS_MANAGER_BCACHE_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_MANAGER_BCACHE_SKELETON, UDisksManagerBcacheSkeletonClass))
#define UDISKS_MANAGER_BCACHE_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_MANAGER_BCACHE_SKELETON, UDisksManagerBcacheSkeletonClass))
#define UDISKS_IS_MANAGER_BCACHE_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_MANAGER_BCACHE_SKELETON))
#define UDISKS_IS_MANAGER_BCACHE_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_MANAGER_BCACHE_SKELETON))

typedef struct _UDisksManagerBcacheSkeleton UDisksManagerBcacheSkeleton;
typedef struct _UDisksManagerBcacheSkeletonClass UDisksManagerBcacheSkeletonClass;
typedef struct _UDisksManagerBcacheSkeletonPrivate UDisksManagerBcacheSkeletonPrivate;

struct _UDisksManagerBcacheSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksManagerBcacheSkeletonPrivate *priv;
};

struct _UDisksManagerBcacheSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_manager_bcache_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksManagerBcacheSkeleton, g_object_unref)
#endif

UDisksManagerBcache *udisks_manager_bcache_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Block.Bcache */

#define UDISKS_TYPE_BLOCK_BCACHE (udisks_block_bcache_get_type ())
#define UDISKS_BLOCK_BCACHE(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_BLOCK_BCACHE, UDisksBlockBcache))
#define UDISKS_IS_BLOCK_BCACHE(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_BLOCK_BCACHE))
#define UDISKS_BLOCK_BCACHE_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_BLOCK_BCACHE, UDisksBlockBcacheIface))

struct _UDisksBlockBcache;
typedef struct _UDisksBlockBcache UDisksBlockBcache;
typedef struct _UDisksBlockBcacheIface UDisksBlockBcacheIface;

struct _UDisksBlockBcacheIface
{
  GTypeInterface parent_iface;


  guint64  (*get_block_size) (UDisksBlockBcache *object);

  guint64  (*get_bypass_hits) (UDisksBlockBcache *object);

  guint64  (*get_bypass_misses) (UDisksBlockBcache *object);

  guint64  (*get_cache_size) (UDisksBlockBcache *object);

  guint64  (*get_cache_used) (UDisksBlockBcache *object);

  guint64  (*get_hits) (UDisksBlockBcache *object);

  guint64  (*get_misses) (UDisksBlockBcache *object);

  const gchar * (*get_mode) (UDisksBlockBcache *object);

  const gchar * (*get_state) (UDisksBlockBcache *object);

  gboolean (*handle_bcache_destroy) (
    UDisksBlockBcache *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_set_mode) (
    UDisksBlockBcache *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_mode,
    GVariant *arg_options);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksBlockBcache, g_object_unref)
#endif

GType udisks_block_bcache_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_block_bcache_interface_info (void);
guint udisks_block_bcache_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_block_bcache_complete_bcache_destroy (
    UDisksBlockBcache *object,
    GDBusMethodInvocation *invocation);

void udisks_block_bcache_complete_set_mode (
    UDisksBlockBcache *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void udisks_block_bcache_call_bcache_destroy (
    UDisksBlockBcache *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_block_bcache_call_bcache_destroy_finish (
    UDisksBlockBcache *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_block_bcache_call_bcache_destroy_sync (
    UDisksBlockBcache *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_block_bcache_call_set_mode (
    UDisksBlockBcache *proxy,
    const gchar *arg_mode,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_block_bcache_call_set_mode_finish (
    UDisksBlockBcache *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_block_bcache_call_set_mode_sync (
    UDisksBlockBcache *proxy,
    const gchar *arg_mode,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
const gchar *udisks_block_bcache_get_mode (UDisksBlockBcache *object);
gchar *udisks_block_bcache_dup_mode (UDisksBlockBcache *object);
void udisks_block_bcache_set_mode (UDisksBlockBcache *object, const gchar *value);

const gchar *udisks_block_bcache_get_state (UDisksBlockBcache *object);
gchar *udisks_block_bcache_dup_state (UDisksBlockBcache *object);
void udisks_block_bcache_set_state (UDisksBlockBcache *object, const gchar *value);

guint64 udisks_block_bcache_get_block_size (UDisksBlockBcache *object);
void udisks_block_bcache_set_block_size (UDisksBlockBcache *object, guint64 value);

guint64 udisks_block_bcache_get_cache_size (UDisksBlockBcache *object);
void udisks_block_bcache_set_cache_size (UDisksBlockBcache *object, guint64 value);

guint64 udisks_block_bcache_get_cache_used (UDisksBlockBcache *object);
void udisks_block_bcache_set_cache_used (UDisksBlockBcache *object, guint64 value);

guint64 udisks_block_bcache_get_hits (UDisksBlockBcache *object);
void udisks_block_bcache_set_hits (UDisksBlockBcache *object, guint64 value);

guint64 udisks_block_bcache_get_misses (UDisksBlockBcache *object);
void udisks_block_bcache_set_misses (UDisksBlockBcache *object, guint64 value);

guint64 udisks_block_bcache_get_bypass_hits (UDisksBlockBcache *object);
void udisks_block_bcache_set_bypass_hits (UDisksBlockBcache *object, guint64 value);

guint64 udisks_block_bcache_get_bypass_misses (UDisksBlockBcache *object);
void udisks_block_bcache_set_bypass_misses (UDisksBlockBcache *object, guint64 value);


/* ---- */

#define UDISKS_TYPE_BLOCK_BCACHE_PROXY (udisks_block_bcache_proxy_get_type ())
#define UDISKS_BLOCK_BCACHE_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_BLOCK_BCACHE_PROXY, UDisksBlockBcacheProxy))
#define UDISKS_BLOCK_BCACHE_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_BLOCK_BCACHE_PROXY, UDisksBlockBcacheProxyClass))
#define UDISKS_BLOCK_BCACHE_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_BLOCK_BCACHE_PROXY, UDisksBlockBcacheProxyClass))
#define UDISKS_IS_BLOCK_BCACHE_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_BLOCK_BCACHE_PROXY))
#define UDISKS_IS_BLOCK_BCACHE_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_BLOCK_BCACHE_PROXY))

typedef struct _UDisksBlockBcacheProxy UDisksBlockBcacheProxy;
typedef struct _UDisksBlockBcacheProxyClass UDisksBlockBcacheProxyClass;
typedef struct _UDisksBlockBcacheProxyPrivate UDisksBlockBcacheProxyPrivate;

struct _UDisksBlockBcacheProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksBlockBcacheProxyPrivate *priv;
};

struct _UDisksBlockBcacheProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_block_bcache_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksBlockBcacheProxy, g_object_unref)
#endif

void udisks_block_bcache_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksBlockBcache *udisks_block_bcache_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksBlockBcache *udisks_block_bcache_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_block_bcache_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksBlockBcache *udisks_block_bcache_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksBlockBcache *udisks_block_bcache_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_BLOCK_BCACHE_SKELETON (udisks_block_bcache_skeleton_get_type ())
#define UDISKS_BLOCK_BCACHE_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_BLOCK_BCACHE_SKELETON, UDisksBlockBcacheSkeleton))
#define UDISKS_BLOCK_BCACHE_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_BLOCK_BCACHE_SKELETON, UDisksBlockBcacheSkeletonClass))
#define UDISKS_BLOCK_BCACHE_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_BLOCK_BCACHE_SKELETON, UDisksBlockBcacheSkeletonClass))
#define UDISKS_IS_BLOCK_BCACHE_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_BLOCK_BCACHE_SKELETON))
#define UDISKS_IS_BLOCK_BCACHE_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_BLOCK_BCACHE_SKELETON))

typedef struct _UDisksBlockBcacheSkeleton UDisksBlockBcacheSkeleton;
typedef struct _UDisksBlockBcacheSkeletonClass UDisksBlockBcacheSkeletonClass;
typedef struct _UDisksBlockBcacheSkeletonPrivate UDisksBlockBcacheSkeletonPrivate;

struct _UDisksBlockBcacheSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksBlockBcacheSkeletonPrivate *priv;
};

struct _UDisksBlockBcacheSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_block_bcache_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksBlockBcacheSkeleton, g_object_unref)
#endif

UDisksBlockBcache *udisks_block_bcache_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Manager.BTRFS */

#define UDISKS_TYPE_MANAGER_BTRFS (udisks_manager_btrfs_get_type ())
#define UDISKS_MANAGER_BTRFS(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_MANAGER_BTRFS, UDisksManagerBTRFS))
#define UDISKS_IS_MANAGER_BTRFS(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_MANAGER_BTRFS))
#define UDISKS_MANAGER_BTRFS_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_MANAGER_BTRFS, UDisksManagerBTRFSIface))

struct _UDisksManagerBTRFS;
typedef struct _UDisksManagerBTRFS UDisksManagerBTRFS;
typedef struct _UDisksManagerBTRFSIface UDisksManagerBTRFSIface;

struct _UDisksManagerBTRFSIface
{
  GTypeInterface parent_iface;

  gboolean (*handle_create_volume) (
    UDisksManagerBTRFS *object,
    GDBusMethodInvocation *invocation,
    const gchar *const *arg_devices,
    const gchar *arg_label,
    const gchar *arg_data_level,
    const gchar *arg_md_level,
    GVariant *arg_options);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksManagerBTRFS, g_object_unref)
#endif

GType udisks_manager_btrfs_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_manager_btrfs_interface_info (void);
guint udisks_manager_btrfs_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_manager_btrfs_complete_create_volume (
    UDisksManagerBTRFS *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void udisks_manager_btrfs_call_create_volume (
    UDisksManagerBTRFS *proxy,
    const gchar *const *arg_devices,
    const gchar *arg_label,
    const gchar *arg_data_level,
    const gchar *arg_md_level,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_manager_btrfs_call_create_volume_finish (
    UDisksManagerBTRFS *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_manager_btrfs_call_create_volume_sync (
    UDisksManagerBTRFS *proxy,
    const gchar *const *arg_devices,
    const gchar *arg_label,
    const gchar *arg_data_level,
    const gchar *arg_md_level,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);



/* ---- */

#define UDISKS_TYPE_MANAGER_BTRFS_PROXY (udisks_manager_btrfs_proxy_get_type ())
#define UDISKS_MANAGER_BTRFS_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_MANAGER_BTRFS_PROXY, UDisksManagerBTRFSProxy))
#define UDISKS_MANAGER_BTRFS_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_MANAGER_BTRFS_PROXY, UDisksManagerBTRFSProxyClass))
#define UDISKS_MANAGER_BTRFS_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_MANAGER_BTRFS_PROXY, UDisksManagerBTRFSProxyClass))
#define UDISKS_IS_MANAGER_BTRFS_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_MANAGER_BTRFS_PROXY))
#define UDISKS_IS_MANAGER_BTRFS_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_MANAGER_BTRFS_PROXY))

typedef struct _UDisksManagerBTRFSProxy UDisksManagerBTRFSProxy;
typedef struct _UDisksManagerBTRFSProxyClass UDisksManagerBTRFSProxyClass;
typedef struct _UDisksManagerBTRFSProxyPrivate UDisksManagerBTRFSProxyPrivate;

struct _UDisksManagerBTRFSProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksManagerBTRFSProxyPrivate *priv;
};

struct _UDisksManagerBTRFSProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_manager_btrfs_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksManagerBTRFSProxy, g_object_unref)
#endif

void udisks_manager_btrfs_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksManagerBTRFS *udisks_manager_btrfs_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksManagerBTRFS *udisks_manager_btrfs_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_manager_btrfs_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksManagerBTRFS *udisks_manager_btrfs_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksManagerBTRFS *udisks_manager_btrfs_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_MANAGER_BTRFS_SKELETON (udisks_manager_btrfs_skeleton_get_type ())
#define UDISKS_MANAGER_BTRFS_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_MANAGER_BTRFS_SKELETON, UDisksManagerBTRFSSkeleton))
#define UDISKS_MANAGER_BTRFS_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_MANAGER_BTRFS_SKELETON, UDisksManagerBTRFSSkeletonClass))
#define UDISKS_MANAGER_BTRFS_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_MANAGER_BTRFS_SKELETON, UDisksManagerBTRFSSkeletonClass))
#define UDISKS_IS_MANAGER_BTRFS_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_MANAGER_BTRFS_SKELETON))
#define UDISKS_IS_MANAGER_BTRFS_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_MANAGER_BTRFS_SKELETON))

typedef struct _UDisksManagerBTRFSSkeleton UDisksManagerBTRFSSkeleton;
typedef struct _UDisksManagerBTRFSSkeletonClass UDisksManagerBTRFSSkeletonClass;
typedef struct _UDisksManagerBTRFSSkeletonPrivate UDisksManagerBTRFSSkeletonPrivate;

struct _UDisksManagerBTRFSSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksManagerBTRFSSkeletonPrivate *priv;
};

struct _UDisksManagerBTRFSSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_manager_btrfs_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksManagerBTRFSSkeleton, g_object_unref)
#endif

UDisksManagerBTRFS *udisks_manager_btrfs_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Filesystem.BTRFS */

#define UDISKS_TYPE_FILESYSTEM_BTRFS (udisks_filesystem_btrfs_get_type ())
#define UDISKS_FILESYSTEM_BTRFS(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_FILESYSTEM_BTRFS, UDisksFilesystemBTRFS))
#define UDISKS_IS_FILESYSTEM_BTRFS(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_FILESYSTEM_BTRFS))
#define UDISKS_FILESYSTEM_BTRFS_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_FILESYSTEM_BTRFS, UDisksFilesystemBTRFSIface))

struct _UDisksFilesystemBTRFS;
typedef struct _UDisksFilesystemBTRFS UDisksFilesystemBTRFS;
typedef struct _UDisksFilesystemBTRFSIface UDisksFilesystemBTRFSIface;

struct _UDisksFilesystemBTRFSIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_create_snapshot) (
    UDisksFilesystemBTRFS *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_source,
    const gchar *arg_dest,
    gboolean arg_ro,
    GVariant *arg_options);

  gboolean (*handle_create_subvolume) (
    UDisksFilesystemBTRFS *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_name,
    GVariant *arg_options);

  gboolean (*handle_get_subvolumes) (
    UDisksFilesystemBTRFS *object,
    GDBusMethodInvocation *invocation,
    gboolean arg_snapshots_only,
    GVariant *arg_options);

  gboolean (*handle_remove_subvolume) (
    UDisksFilesystemBTRFS *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_name,
    GVariant *arg_options);

  gboolean (*handle_set_label) (
    UDisksFilesystemBTRFS *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_label,
    GVariant *arg_options);

  const gchar * (*get_label) (UDisksFilesystemBTRFS *object);

  guint64  (*get_num_devices) (UDisksFilesystemBTRFS *object);

  guint64  (*get_used) (UDisksFilesystemBTRFS *object);

  const gchar * (*get_uuid) (UDisksFilesystemBTRFS *object);

  gboolean (*handle_add_device) (
    UDisksFilesystemBTRFS *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_device,
    GVariant *arg_options);

  gboolean (*handle_remove_device) (
    UDisksFilesystemBTRFS *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_device,
    GVariant *arg_options);

  gboolean (*handle_repair) (
    UDisksFilesystemBTRFS *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_resize) (
    UDisksFilesystemBTRFS *object,
    GDBusMethodInvocation *invocation,
    guint64 arg_size,
    GVariant *arg_options);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksFilesystemBTRFS, g_object_unref)
#endif

GType udisks_filesystem_btrfs_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_filesystem_btrfs_interface_info (void);
guint udisks_filesystem_btrfs_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_filesystem_btrfs_complete_add_device (
    UDisksFilesystemBTRFS *object,
    GDBusMethodInvocation *invocation);

void udisks_filesystem_btrfs_complete_remove_device (
    UDisksFilesystemBTRFS *object,
    GDBusMethodInvocation *invocation);

void udisks_filesystem_btrfs_complete_create_subvolume (
    UDisksFilesystemBTRFS *object,
    GDBusMethodInvocation *invocation);

void udisks_filesystem_btrfs_complete_remove_subvolume (
    UDisksFilesystemBTRFS *object,
    GDBusMethodInvocation *invocation);

void udisks_filesystem_btrfs_complete_get_subvolumes (
    UDisksFilesystemBTRFS *object,
    GDBusMethodInvocation *invocation,
    GVariant *subvolumes,
    gint subvolumes_cnt);

void udisks_filesystem_btrfs_complete_create_snapshot (
    UDisksFilesystemBTRFS *object,
    GDBusMethodInvocation *invocation);

void udisks_filesystem_btrfs_complete_repair (
    UDisksFilesystemBTRFS *object,
    GDBusMethodInvocation *invocation);

void udisks_filesystem_btrfs_complete_resize (
    UDisksFilesystemBTRFS *object,
    GDBusMethodInvocation *invocation);

void udisks_filesystem_btrfs_complete_set_label (
    UDisksFilesystemBTRFS *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void udisks_filesystem_btrfs_call_add_device (
    UDisksFilesystemBTRFS *proxy,
    const gchar *arg_device,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_filesystem_btrfs_call_add_device_finish (
    UDisksFilesystemBTRFS *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_filesystem_btrfs_call_add_device_sync (
    UDisksFilesystemBTRFS *proxy,
    const gchar *arg_device,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_filesystem_btrfs_call_remove_device (
    UDisksFilesystemBTRFS *proxy,
    const gchar *arg_device,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_filesystem_btrfs_call_remove_device_finish (
    UDisksFilesystemBTRFS *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_filesystem_btrfs_call_remove_device_sync (
    UDisksFilesystemBTRFS *proxy,
    const gchar *arg_device,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_filesystem_btrfs_call_create_subvolume (
    UDisksFilesystemBTRFS *proxy,
    const gchar *arg_name,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_filesystem_btrfs_call_create_subvolume_finish (
    UDisksFilesystemBTRFS *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_filesystem_btrfs_call_create_subvolume_sync (
    UDisksFilesystemBTRFS *proxy,
    const gchar *arg_name,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_filesystem_btrfs_call_remove_subvolume (
    UDisksFilesystemBTRFS *proxy,
    const gchar *arg_name,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_filesystem_btrfs_call_remove_subvolume_finish (
    UDisksFilesystemBTRFS *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_filesystem_btrfs_call_remove_subvolume_sync (
    UDisksFilesystemBTRFS *proxy,
    const gchar *arg_name,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_filesystem_btrfs_call_get_subvolumes (
    UDisksFilesystemBTRFS *proxy,
    gboolean arg_snapshots_only,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_filesystem_btrfs_call_get_subvolumes_finish (
    UDisksFilesystemBTRFS *proxy,
    GVariant **out_subvolumes,
    gint *out_subvolumes_cnt,
    GAsyncResult *res,
    GError **error);

gboolean udisks_filesystem_btrfs_call_get_subvolumes_sync (
    UDisksFilesystemBTRFS *proxy,
    gboolean arg_snapshots_only,
    GVariant *arg_options,
    GVariant **out_subvolumes,
    gint *out_subvolumes_cnt,
    GCancellable *cancellable,
    GError **error);

void udisks_filesystem_btrfs_call_create_snapshot (
    UDisksFilesystemBTRFS *proxy,
    const gchar *arg_source,
    const gchar *arg_dest,
    gboolean arg_ro,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_filesystem_btrfs_call_create_snapshot_finish (
    UDisksFilesystemBTRFS *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_filesystem_btrfs_call_create_snapshot_sync (
    UDisksFilesystemBTRFS *proxy,
    const gchar *arg_source,
    const gchar *arg_dest,
    gboolean arg_ro,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_filesystem_btrfs_call_repair (
    UDisksFilesystemBTRFS *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_filesystem_btrfs_call_repair_finish (
    UDisksFilesystemBTRFS *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_filesystem_btrfs_call_repair_sync (
    UDisksFilesystemBTRFS *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_filesystem_btrfs_call_resize (
    UDisksFilesystemBTRFS *proxy,
    guint64 arg_size,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_filesystem_btrfs_call_resize_finish (
    UDisksFilesystemBTRFS *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_filesystem_btrfs_call_resize_sync (
    UDisksFilesystemBTRFS *proxy,
    guint64 arg_size,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_filesystem_btrfs_call_set_label (
    UDisksFilesystemBTRFS *proxy,
    const gchar *arg_label,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_filesystem_btrfs_call_set_label_finish (
    UDisksFilesystemBTRFS *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_filesystem_btrfs_call_set_label_sync (
    UDisksFilesystemBTRFS *proxy,
    const gchar *arg_label,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
const gchar *udisks_filesystem_btrfs_get_label (UDisksFilesystemBTRFS *object);
gchar *udisks_filesystem_btrfs_dup_label (UDisksFilesystemBTRFS *object);
void udisks_filesystem_btrfs_set_label (UDisksFilesystemBTRFS *object, const gchar *value);

const gchar *udisks_filesystem_btrfs_get_uuid (UDisksFilesystemBTRFS *object);
gchar *udisks_filesystem_btrfs_dup_uuid (UDisksFilesystemBTRFS *object);
void udisks_filesystem_btrfs_set_uuid (UDisksFilesystemBTRFS *object, const gchar *value);

guint64 udisks_filesystem_btrfs_get_num_devices (UDisksFilesystemBTRFS *object);
void udisks_filesystem_btrfs_set_num_devices (UDisksFilesystemBTRFS *object, guint64 value);

guint64 udisks_filesystem_btrfs_get_used (UDisksFilesystemBTRFS *object);
void udisks_filesystem_btrfs_set_used (UDisksFilesystemBTRFS *object, guint64 value);


/* ---- */

#define UDISKS_TYPE_FILESYSTEM_BTRFS_PROXY (udisks_filesystem_btrfs_proxy_get_type ())
#define UDISKS_FILESYSTEM_BTRFS_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_FILESYSTEM_BTRFS_PROXY, UDisksFilesystemBTRFSProxy))
#define UDISKS_FILESYSTEM_BTRFS_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_FILESYSTEM_BTRFS_PROXY, UDisksFilesystemBTRFSProxyClass))
#define UDISKS_FILESYSTEM_BTRFS_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_FILESYSTEM_BTRFS_PROXY, UDisksFilesystemBTRFSProxyClass))
#define UDISKS_IS_FILESYSTEM_BTRFS_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_FILESYSTEM_BTRFS_PROXY))
#define UDISKS_IS_FILESYSTEM_BTRFS_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_FILESYSTEM_BTRFS_PROXY))

typedef struct _UDisksFilesystemBTRFSProxy UDisksFilesystemBTRFSProxy;
typedef struct _UDisksFilesystemBTRFSProxyClass UDisksFilesystemBTRFSProxyClass;
typedef struct _UDisksFilesystemBTRFSProxyPrivate UDisksFilesystemBTRFSProxyPrivate;

struct _UDisksFilesystemBTRFSProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksFilesystemBTRFSProxyPrivate *priv;
};

struct _UDisksFilesystemBTRFSProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_filesystem_btrfs_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksFilesystemBTRFSProxy, g_object_unref)
#endif

void udisks_filesystem_btrfs_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksFilesystemBTRFS *udisks_filesystem_btrfs_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksFilesystemBTRFS *udisks_filesystem_btrfs_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_filesystem_btrfs_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksFilesystemBTRFS *udisks_filesystem_btrfs_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksFilesystemBTRFS *udisks_filesystem_btrfs_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_FILESYSTEM_BTRFS_SKELETON (udisks_filesystem_btrfs_skeleton_get_type ())
#define UDISKS_FILESYSTEM_BTRFS_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_FILESYSTEM_BTRFS_SKELETON, UDisksFilesystemBTRFSSkeleton))
#define UDISKS_FILESYSTEM_BTRFS_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_FILESYSTEM_BTRFS_SKELETON, UDisksFilesystemBTRFSSkeletonClass))
#define UDISKS_FILESYSTEM_BTRFS_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_FILESYSTEM_BTRFS_SKELETON, UDisksFilesystemBTRFSSkeletonClass))
#define UDISKS_IS_FILESYSTEM_BTRFS_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_FILESYSTEM_BTRFS_SKELETON))
#define UDISKS_IS_FILESYSTEM_BTRFS_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_FILESYSTEM_BTRFS_SKELETON))

typedef struct _UDisksFilesystemBTRFSSkeleton UDisksFilesystemBTRFSSkeleton;
typedef struct _UDisksFilesystemBTRFSSkeletonClass UDisksFilesystemBTRFSSkeletonClass;
typedef struct _UDisksFilesystemBTRFSSkeletonPrivate UDisksFilesystemBTRFSSkeletonPrivate;

struct _UDisksFilesystemBTRFSSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksFilesystemBTRFSSkeletonPrivate *priv;
};

struct _UDisksFilesystemBTRFSSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_filesystem_btrfs_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksFilesystemBTRFSSkeleton, g_object_unref)
#endif

UDisksFilesystemBTRFS *udisks_filesystem_btrfs_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Manager.LVM2 */

#define UDISKS_TYPE_MANAGER_LVM2 (udisks_manager_lvm2_get_type ())
#define UDISKS_MANAGER_LVM2(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_MANAGER_LVM2, UDisksManagerLVM2))
#define UDISKS_IS_MANAGER_LVM2(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_MANAGER_LVM2))
#define UDISKS_MANAGER_LVM2_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_MANAGER_LVM2, UDisksManagerLVM2Iface))

struct _UDisksManagerLVM2;
typedef struct _UDisksManagerLVM2 UDisksManagerLVM2;
typedef struct _UDisksManagerLVM2Iface UDisksManagerLVM2Iface;

struct _UDisksManagerLVM2Iface
{
  GTypeInterface parent_iface;

  gboolean (*handle_volume_group_create) (
    UDisksManagerLVM2 *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_name,
    const gchar *const *arg_blocks,
    GVariant *arg_options);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksManagerLVM2, g_object_unref)
#endif

GType udisks_manager_lvm2_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_manager_lvm2_interface_info (void);
guint udisks_manager_lvm2_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_manager_lvm2_complete_volume_group_create (
    UDisksManagerLVM2 *object,
    GDBusMethodInvocation *invocation,
    const gchar *result);



/* D-Bus method calls: */
void udisks_manager_lvm2_call_volume_group_create (
    UDisksManagerLVM2 *proxy,
    const gchar *arg_name,
    const gchar *const *arg_blocks,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_manager_lvm2_call_volume_group_create_finish (
    UDisksManagerLVM2 *proxy,
    gchar **out_result,
    GAsyncResult *res,
    GError **error);

gboolean udisks_manager_lvm2_call_volume_group_create_sync (
    UDisksManagerLVM2 *proxy,
    const gchar *arg_name,
    const gchar *const *arg_blocks,
    GVariant *arg_options,
    gchar **out_result,
    GCancellable *cancellable,
    GError **error);



/* ---- */

#define UDISKS_TYPE_MANAGER_LVM2_PROXY (udisks_manager_lvm2_proxy_get_type ())
#define UDISKS_MANAGER_LVM2_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_MANAGER_LVM2_PROXY, UDisksManagerLVM2Proxy))
#define UDISKS_MANAGER_LVM2_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_MANAGER_LVM2_PROXY, UDisksManagerLVM2ProxyClass))
#define UDISKS_MANAGER_LVM2_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_MANAGER_LVM2_PROXY, UDisksManagerLVM2ProxyClass))
#define UDISKS_IS_MANAGER_LVM2_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_MANAGER_LVM2_PROXY))
#define UDISKS_IS_MANAGER_LVM2_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_MANAGER_LVM2_PROXY))

typedef struct _UDisksManagerLVM2Proxy UDisksManagerLVM2Proxy;
typedef struct _UDisksManagerLVM2ProxyClass UDisksManagerLVM2ProxyClass;
typedef struct _UDisksManagerLVM2ProxyPrivate UDisksManagerLVM2ProxyPrivate;

struct _UDisksManagerLVM2Proxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksManagerLVM2ProxyPrivate *priv;
};

struct _UDisksManagerLVM2ProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_manager_lvm2_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksManagerLVM2Proxy, g_object_unref)
#endif

void udisks_manager_lvm2_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksManagerLVM2 *udisks_manager_lvm2_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksManagerLVM2 *udisks_manager_lvm2_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_manager_lvm2_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksManagerLVM2 *udisks_manager_lvm2_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksManagerLVM2 *udisks_manager_lvm2_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_MANAGER_LVM2_SKELETON (udisks_manager_lvm2_skeleton_get_type ())
#define UDISKS_MANAGER_LVM2_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_MANAGER_LVM2_SKELETON, UDisksManagerLVM2Skeleton))
#define UDISKS_MANAGER_LVM2_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_MANAGER_LVM2_SKELETON, UDisksManagerLVM2SkeletonClass))
#define UDISKS_MANAGER_LVM2_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_MANAGER_LVM2_SKELETON, UDisksManagerLVM2SkeletonClass))
#define UDISKS_IS_MANAGER_LVM2_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_MANAGER_LVM2_SKELETON))
#define UDISKS_IS_MANAGER_LVM2_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_MANAGER_LVM2_SKELETON))

typedef struct _UDisksManagerLVM2Skeleton UDisksManagerLVM2Skeleton;
typedef struct _UDisksManagerLVM2SkeletonClass UDisksManagerLVM2SkeletonClass;
typedef struct _UDisksManagerLVM2SkeletonPrivate UDisksManagerLVM2SkeletonPrivate;

struct _UDisksManagerLVM2Skeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksManagerLVM2SkeletonPrivate *priv;
};

struct _UDisksManagerLVM2SkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_manager_lvm2_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksManagerLVM2Skeleton, g_object_unref)
#endif

UDisksManagerLVM2 *udisks_manager_lvm2_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Block.LVM2 */

#define UDISKS_TYPE_BLOCK_LVM2 (udisks_block_lvm2_get_type ())
#define UDISKS_BLOCK_LVM2(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_BLOCK_LVM2, UDisksBlockLVM2))
#define UDISKS_IS_BLOCK_LVM2(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_BLOCK_LVM2))
#define UDISKS_BLOCK_LVM2_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_BLOCK_LVM2, UDisksBlockLVM2Iface))

struct _UDisksBlockLVM2;
typedef struct _UDisksBlockLVM2 UDisksBlockLVM2;
typedef struct _UDisksBlockLVM2Iface UDisksBlockLVM2Iface;

struct _UDisksBlockLVM2Iface
{
  GTypeInterface parent_iface;

  const gchar * (*get_logical_volume) (UDisksBlockLVM2 *object);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksBlockLVM2, g_object_unref)
#endif

GType udisks_block_lvm2_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_block_lvm2_interface_info (void);
guint udisks_block_lvm2_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus property accessors: */
const gchar *udisks_block_lvm2_get_logical_volume (UDisksBlockLVM2 *object);
gchar *udisks_block_lvm2_dup_logical_volume (UDisksBlockLVM2 *object);
void udisks_block_lvm2_set_logical_volume (UDisksBlockLVM2 *object, const gchar *value);


/* ---- */

#define UDISKS_TYPE_BLOCK_LVM2_PROXY (udisks_block_lvm2_proxy_get_type ())
#define UDISKS_BLOCK_LVM2_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_BLOCK_LVM2_PROXY, UDisksBlockLVM2Proxy))
#define UDISKS_BLOCK_LVM2_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_BLOCK_LVM2_PROXY, UDisksBlockLVM2ProxyClass))
#define UDISKS_BLOCK_LVM2_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_BLOCK_LVM2_PROXY, UDisksBlockLVM2ProxyClass))
#define UDISKS_IS_BLOCK_LVM2_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_BLOCK_LVM2_PROXY))
#define UDISKS_IS_BLOCK_LVM2_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_BLOCK_LVM2_PROXY))

typedef struct _UDisksBlockLVM2Proxy UDisksBlockLVM2Proxy;
typedef struct _UDisksBlockLVM2ProxyClass UDisksBlockLVM2ProxyClass;
typedef struct _UDisksBlockLVM2ProxyPrivate UDisksBlockLVM2ProxyPrivate;

struct _UDisksBlockLVM2Proxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksBlockLVM2ProxyPrivate *priv;
};

struct _UDisksBlockLVM2ProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_block_lvm2_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksBlockLVM2Proxy, g_object_unref)
#endif

void udisks_block_lvm2_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksBlockLVM2 *udisks_block_lvm2_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksBlockLVM2 *udisks_block_lvm2_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_block_lvm2_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksBlockLVM2 *udisks_block_lvm2_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksBlockLVM2 *udisks_block_lvm2_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_BLOCK_LVM2_SKELETON (udisks_block_lvm2_skeleton_get_type ())
#define UDISKS_BLOCK_LVM2_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_BLOCK_LVM2_SKELETON, UDisksBlockLVM2Skeleton))
#define UDISKS_BLOCK_LVM2_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_BLOCK_LVM2_SKELETON, UDisksBlockLVM2SkeletonClass))
#define UDISKS_BLOCK_LVM2_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_BLOCK_LVM2_SKELETON, UDisksBlockLVM2SkeletonClass))
#define UDISKS_IS_BLOCK_LVM2_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_BLOCK_LVM2_SKELETON))
#define UDISKS_IS_BLOCK_LVM2_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_BLOCK_LVM2_SKELETON))

typedef struct _UDisksBlockLVM2Skeleton UDisksBlockLVM2Skeleton;
typedef struct _UDisksBlockLVM2SkeletonClass UDisksBlockLVM2SkeletonClass;
typedef struct _UDisksBlockLVM2SkeletonPrivate UDisksBlockLVM2SkeletonPrivate;

struct _UDisksBlockLVM2Skeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksBlockLVM2SkeletonPrivate *priv;
};

struct _UDisksBlockLVM2SkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_block_lvm2_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksBlockLVM2Skeleton, g_object_unref)
#endif

UDisksBlockLVM2 *udisks_block_lvm2_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.PhysicalVolume */

#define UDISKS_TYPE_PHYSICAL_VOLUME (udisks_physical_volume_get_type ())
#define UDISKS_PHYSICAL_VOLUME(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_PHYSICAL_VOLUME, UDisksPhysicalVolume))
#define UDISKS_IS_PHYSICAL_VOLUME(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_PHYSICAL_VOLUME))
#define UDISKS_PHYSICAL_VOLUME_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_PHYSICAL_VOLUME, UDisksPhysicalVolumeIface))

struct _UDisksPhysicalVolume;
typedef struct _UDisksPhysicalVolume UDisksPhysicalVolume;
typedef struct _UDisksPhysicalVolumeIface UDisksPhysicalVolumeIface;

struct _UDisksPhysicalVolumeIface
{
  GTypeInterface parent_iface;

  guint64  (*get_free_size) (UDisksPhysicalVolume *object);

  guint64  (*get_size) (UDisksPhysicalVolume *object);

  const gchar * (*get_volume_group) (UDisksPhysicalVolume *object);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksPhysicalVolume, g_object_unref)
#endif

GType udisks_physical_volume_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_physical_volume_interface_info (void);
guint udisks_physical_volume_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus property accessors: */
const gchar *udisks_physical_volume_get_volume_group (UDisksPhysicalVolume *object);
gchar *udisks_physical_volume_dup_volume_group (UDisksPhysicalVolume *object);
void udisks_physical_volume_set_volume_group (UDisksPhysicalVolume *object, const gchar *value);

guint64 udisks_physical_volume_get_size (UDisksPhysicalVolume *object);
void udisks_physical_volume_set_size (UDisksPhysicalVolume *object, guint64 value);

guint64 udisks_physical_volume_get_free_size (UDisksPhysicalVolume *object);
void udisks_physical_volume_set_free_size (UDisksPhysicalVolume *object, guint64 value);


/* ---- */

#define UDISKS_TYPE_PHYSICAL_VOLUME_PROXY (udisks_physical_volume_proxy_get_type ())
#define UDISKS_PHYSICAL_VOLUME_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_PHYSICAL_VOLUME_PROXY, UDisksPhysicalVolumeProxy))
#define UDISKS_PHYSICAL_VOLUME_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_PHYSICAL_VOLUME_PROXY, UDisksPhysicalVolumeProxyClass))
#define UDISKS_PHYSICAL_VOLUME_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_PHYSICAL_VOLUME_PROXY, UDisksPhysicalVolumeProxyClass))
#define UDISKS_IS_PHYSICAL_VOLUME_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_PHYSICAL_VOLUME_PROXY))
#define UDISKS_IS_PHYSICAL_VOLUME_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_PHYSICAL_VOLUME_PROXY))

typedef struct _UDisksPhysicalVolumeProxy UDisksPhysicalVolumeProxy;
typedef struct _UDisksPhysicalVolumeProxyClass UDisksPhysicalVolumeProxyClass;
typedef struct _UDisksPhysicalVolumeProxyPrivate UDisksPhysicalVolumeProxyPrivate;

struct _UDisksPhysicalVolumeProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksPhysicalVolumeProxyPrivate *priv;
};

struct _UDisksPhysicalVolumeProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_physical_volume_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksPhysicalVolumeProxy, g_object_unref)
#endif

void udisks_physical_volume_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksPhysicalVolume *udisks_physical_volume_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksPhysicalVolume *udisks_physical_volume_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_physical_volume_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksPhysicalVolume *udisks_physical_volume_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksPhysicalVolume *udisks_physical_volume_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_PHYSICAL_VOLUME_SKELETON (udisks_physical_volume_skeleton_get_type ())
#define UDISKS_PHYSICAL_VOLUME_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_PHYSICAL_VOLUME_SKELETON, UDisksPhysicalVolumeSkeleton))
#define UDISKS_PHYSICAL_VOLUME_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_PHYSICAL_VOLUME_SKELETON, UDisksPhysicalVolumeSkeletonClass))
#define UDISKS_PHYSICAL_VOLUME_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_PHYSICAL_VOLUME_SKELETON, UDisksPhysicalVolumeSkeletonClass))
#define UDISKS_IS_PHYSICAL_VOLUME_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_PHYSICAL_VOLUME_SKELETON))
#define UDISKS_IS_PHYSICAL_VOLUME_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_PHYSICAL_VOLUME_SKELETON))

typedef struct _UDisksPhysicalVolumeSkeleton UDisksPhysicalVolumeSkeleton;
typedef struct _UDisksPhysicalVolumeSkeletonClass UDisksPhysicalVolumeSkeletonClass;
typedef struct _UDisksPhysicalVolumeSkeletonPrivate UDisksPhysicalVolumeSkeletonPrivate;

struct _UDisksPhysicalVolumeSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksPhysicalVolumeSkeletonPrivate *priv;
};

struct _UDisksPhysicalVolumeSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_physical_volume_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksPhysicalVolumeSkeleton, g_object_unref)
#endif

UDisksPhysicalVolume *udisks_physical_volume_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.VolumeGroup */

#define UDISKS_TYPE_VOLUME_GROUP (udisks_volume_group_get_type ())
#define UDISKS_VOLUME_GROUP(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_VOLUME_GROUP, UDisksVolumeGroup))
#define UDISKS_IS_VOLUME_GROUP(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_VOLUME_GROUP))
#define UDISKS_VOLUME_GROUP_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_VOLUME_GROUP, UDisksVolumeGroupIface))

struct _UDisksVolumeGroup;
typedef struct _UDisksVolumeGroup UDisksVolumeGroup;
typedef struct _UDisksVolumeGroupIface UDisksVolumeGroupIface;

struct _UDisksVolumeGroupIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_add_device) (
    UDisksVolumeGroup *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_block,
    GVariant *arg_options);

  gboolean (*handle_create_plain_volume) (
    UDisksVolumeGroup *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_name,
    guint64 arg_size,
    GVariant *arg_options);

  gboolean (*handle_create_thin_pool_volume) (
    UDisksVolumeGroup *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_name,
    guint64 arg_size,
    GVariant *arg_options);

  gboolean (*handle_create_thin_volume) (
    UDisksVolumeGroup *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_name,
    guint64 arg_size,
    const gchar *arg_pool,
    GVariant *arg_options);

  gboolean (*handle_create_vdo_volume) (
    UDisksVolumeGroup *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_lv_name,
    const gchar *arg_pool_name,
    guint64 arg_data_size,
    guint64 arg_virtual_size,
    guint64 arg_index_memory,
    gboolean arg_compression,
    gboolean arg_deduplication,
    const gchar *arg_write_policy,
    GVariant *arg_options);

  gboolean (*handle_delete) (
    UDisksVolumeGroup *object,
    GDBusMethodInvocation *invocation,
    gboolean arg_wipe,
    GVariant *arg_options);

  gboolean (*handle_empty_device) (
    UDisksVolumeGroup *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_block,
    GVariant *arg_options);

  gboolean (*handle_poll) (
    UDisksVolumeGroup *object,
    GDBusMethodInvocation *invocation);

  gboolean (*handle_remove_device) (
    UDisksVolumeGroup *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_block,
    gboolean arg_wipe,
    GVariant *arg_options);

  gboolean (*handle_rename) (
    UDisksVolumeGroup *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_new_name,
    GVariant *arg_options);

  guint64  (*get_extent_size) (UDisksVolumeGroup *object);

  guint64  (*get_free_size) (UDisksVolumeGroup *object);

  const gchar * (*get_name) (UDisksVolumeGroup *object);

  gboolean  (*get_needs_polling) (UDisksVolumeGroup *object);

  guint64  (*get_size) (UDisksVolumeGroup *object);

  const gchar * (*get_uuid) (UDisksVolumeGroup *object);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksVolumeGroup, g_object_unref)
#endif

GType udisks_volume_group_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_volume_group_interface_info (void);
guint udisks_volume_group_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_volume_group_complete_poll (
    UDisksVolumeGroup *object,
    GDBusMethodInvocation *invocation);

void udisks_volume_group_complete_delete (
    UDisksVolumeGroup *object,
    GDBusMethodInvocation *invocation);

void udisks_volume_group_complete_rename (
    UDisksVolumeGroup *object,
    GDBusMethodInvocation *invocation,
    const gchar *result);

void udisks_volume_group_complete_add_device (
    UDisksVolumeGroup *object,
    GDBusMethodInvocation *invocation);

void udisks_volume_group_complete_empty_device (
    UDisksVolumeGroup *object,
    GDBusMethodInvocation *invocation);

void udisks_volume_group_complete_remove_device (
    UDisksVolumeGroup *object,
    GDBusMethodInvocation *invocation);

void udisks_volume_group_complete_create_plain_volume (
    UDisksVolumeGroup *object,
    GDBusMethodInvocation *invocation,
    const gchar *result);

void udisks_volume_group_complete_create_thin_pool_volume (
    UDisksVolumeGroup *object,
    GDBusMethodInvocation *invocation,
    const gchar *result);

void udisks_volume_group_complete_create_thin_volume (
    UDisksVolumeGroup *object,
    GDBusMethodInvocation *invocation,
    const gchar *result);

void udisks_volume_group_complete_create_vdo_volume (
    UDisksVolumeGroup *object,
    GDBusMethodInvocation *invocation,
    const gchar *result);



/* D-Bus method calls: */
void udisks_volume_group_call_poll (
    UDisksVolumeGroup *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_volume_group_call_poll_finish (
    UDisksVolumeGroup *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_volume_group_call_poll_sync (
    UDisksVolumeGroup *proxy,
    GCancellable *cancellable,
    GError **error);

void udisks_volume_group_call_delete (
    UDisksVolumeGroup *proxy,
    gboolean arg_wipe,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_volume_group_call_delete_finish (
    UDisksVolumeGroup *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_volume_group_call_delete_sync (
    UDisksVolumeGroup *proxy,
    gboolean arg_wipe,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_volume_group_call_rename (
    UDisksVolumeGroup *proxy,
    const gchar *arg_new_name,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_volume_group_call_rename_finish (
    UDisksVolumeGroup *proxy,
    gchar **out_result,
    GAsyncResult *res,
    GError **error);

gboolean udisks_volume_group_call_rename_sync (
    UDisksVolumeGroup *proxy,
    const gchar *arg_new_name,
    GVariant *arg_options,
    gchar **out_result,
    GCancellable *cancellable,
    GError **error);

void udisks_volume_group_call_add_device (
    UDisksVolumeGroup *proxy,
    const gchar *arg_block,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_volume_group_call_add_device_finish (
    UDisksVolumeGroup *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_volume_group_call_add_device_sync (
    UDisksVolumeGroup *proxy,
    const gchar *arg_block,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_volume_group_call_empty_device (
    UDisksVolumeGroup *proxy,
    const gchar *arg_block,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_volume_group_call_empty_device_finish (
    UDisksVolumeGroup *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_volume_group_call_empty_device_sync (
    UDisksVolumeGroup *proxy,
    const gchar *arg_block,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_volume_group_call_remove_device (
    UDisksVolumeGroup *proxy,
    const gchar *arg_block,
    gboolean arg_wipe,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_volume_group_call_remove_device_finish (
    UDisksVolumeGroup *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_volume_group_call_remove_device_sync (
    UDisksVolumeGroup *proxy,
    const gchar *arg_block,
    gboolean arg_wipe,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_volume_group_call_create_plain_volume (
    UDisksVolumeGroup *proxy,
    const gchar *arg_name,
    guint64 arg_size,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_volume_group_call_create_plain_volume_finish (
    UDisksVolumeGroup *proxy,
    gchar **out_result,
    GAsyncResult *res,
    GError **error);

gboolean udisks_volume_group_call_create_plain_volume_sync (
    UDisksVolumeGroup *proxy,
    const gchar *arg_name,
    guint64 arg_size,
    GVariant *arg_options,
    gchar **out_result,
    GCancellable *cancellable,
    GError **error);

void udisks_volume_group_call_create_thin_pool_volume (
    UDisksVolumeGroup *proxy,
    const gchar *arg_name,
    guint64 arg_size,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_volume_group_call_create_thin_pool_volume_finish (
    UDisksVolumeGroup *proxy,
    gchar **out_result,
    GAsyncResult *res,
    GError **error);

gboolean udisks_volume_group_call_create_thin_pool_volume_sync (
    UDisksVolumeGroup *proxy,
    const gchar *arg_name,
    guint64 arg_size,
    GVariant *arg_options,
    gchar **out_result,
    GCancellable *cancellable,
    GError **error);

void udisks_volume_group_call_create_thin_volume (
    UDisksVolumeGroup *proxy,
    const gchar *arg_name,
    guint64 arg_size,
    const gchar *arg_pool,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_volume_group_call_create_thin_volume_finish (
    UDisksVolumeGroup *proxy,
    gchar **out_result,
    GAsyncResult *res,
    GError **error);

gboolean udisks_volume_group_call_create_thin_volume_sync (
    UDisksVolumeGroup *proxy,
    const gchar *arg_name,
    guint64 arg_size,
    const gchar *arg_pool,
    GVariant *arg_options,
    gchar **out_result,
    GCancellable *cancellable,
    GError **error);

void udisks_volume_group_call_create_vdo_volume (
    UDisksVolumeGroup *proxy,
    const gchar *arg_lv_name,
    const gchar *arg_pool_name,
    guint64 arg_data_size,
    guint64 arg_virtual_size,
    guint64 arg_index_memory,
    gboolean arg_compression,
    gboolean arg_deduplication,
    const gchar *arg_write_policy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_volume_group_call_create_vdo_volume_finish (
    UDisksVolumeGroup *proxy,
    gchar **out_result,
    GAsyncResult *res,
    GError **error);

gboolean udisks_volume_group_call_create_vdo_volume_sync (
    UDisksVolumeGroup *proxy,
    const gchar *arg_lv_name,
    const gchar *arg_pool_name,
    guint64 arg_data_size,
    guint64 arg_virtual_size,
    guint64 arg_index_memory,
    gboolean arg_compression,
    gboolean arg_deduplication,
    const gchar *arg_write_policy,
    GVariant *arg_options,
    gchar **out_result,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
const gchar *udisks_volume_group_get_name (UDisksVolumeGroup *object);
gchar *udisks_volume_group_dup_name (UDisksVolumeGroup *object);
void udisks_volume_group_set_name (UDisksVolumeGroup *object, const gchar *value);

const gchar *udisks_volume_group_get_uuid (UDisksVolumeGroup *object);
gchar *udisks_volume_group_dup_uuid (UDisksVolumeGroup *object);
void udisks_volume_group_set_uuid (UDisksVolumeGroup *object, const gchar *value);

guint64 udisks_volume_group_get_size (UDisksVolumeGroup *object);
void udisks_volume_group_set_size (UDisksVolumeGroup *object, guint64 value);

guint64 udisks_volume_group_get_free_size (UDisksVolumeGroup *object);
void udisks_volume_group_set_free_size (UDisksVolumeGroup *object, guint64 value);

guint64 udisks_volume_group_get_extent_size (UDisksVolumeGroup *object);
void udisks_volume_group_set_extent_size (UDisksVolumeGroup *object, guint64 value);

gboolean udisks_volume_group_get_needs_polling (UDisksVolumeGroup *object);
void udisks_volume_group_set_needs_polling (UDisksVolumeGroup *object, gboolean value);


/* ---- */

#define UDISKS_TYPE_VOLUME_GROUP_PROXY (udisks_volume_group_proxy_get_type ())
#define UDISKS_VOLUME_GROUP_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_VOLUME_GROUP_PROXY, UDisksVolumeGroupProxy))
#define UDISKS_VOLUME_GROUP_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_VOLUME_GROUP_PROXY, UDisksVolumeGroupProxyClass))
#define UDISKS_VOLUME_GROUP_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_VOLUME_GROUP_PROXY, UDisksVolumeGroupProxyClass))
#define UDISKS_IS_VOLUME_GROUP_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_VOLUME_GROUP_PROXY))
#define UDISKS_IS_VOLUME_GROUP_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_VOLUME_GROUP_PROXY))

typedef struct _UDisksVolumeGroupProxy UDisksVolumeGroupProxy;
typedef struct _UDisksVolumeGroupProxyClass UDisksVolumeGroupProxyClass;
typedef struct _UDisksVolumeGroupProxyPrivate UDisksVolumeGroupProxyPrivate;

struct _UDisksVolumeGroupProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksVolumeGroupProxyPrivate *priv;
};

struct _UDisksVolumeGroupProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_volume_group_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksVolumeGroupProxy, g_object_unref)
#endif

void udisks_volume_group_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksVolumeGroup *udisks_volume_group_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksVolumeGroup *udisks_volume_group_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_volume_group_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksVolumeGroup *udisks_volume_group_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksVolumeGroup *udisks_volume_group_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_VOLUME_GROUP_SKELETON (udisks_volume_group_skeleton_get_type ())
#define UDISKS_VOLUME_GROUP_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_VOLUME_GROUP_SKELETON, UDisksVolumeGroupSkeleton))
#define UDISKS_VOLUME_GROUP_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_VOLUME_GROUP_SKELETON, UDisksVolumeGroupSkeletonClass))
#define UDISKS_VOLUME_GROUP_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_VOLUME_GROUP_SKELETON, UDisksVolumeGroupSkeletonClass))
#define UDISKS_IS_VOLUME_GROUP_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_VOLUME_GROUP_SKELETON))
#define UDISKS_IS_VOLUME_GROUP_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_VOLUME_GROUP_SKELETON))

typedef struct _UDisksVolumeGroupSkeleton UDisksVolumeGroupSkeleton;
typedef struct _UDisksVolumeGroupSkeletonClass UDisksVolumeGroupSkeletonClass;
typedef struct _UDisksVolumeGroupSkeletonPrivate UDisksVolumeGroupSkeletonPrivate;

struct _UDisksVolumeGroupSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksVolumeGroupSkeletonPrivate *priv;
};

struct _UDisksVolumeGroupSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_volume_group_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksVolumeGroupSkeleton, g_object_unref)
#endif

UDisksVolumeGroup *udisks_volume_group_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.LogicalVolume */

#define UDISKS_TYPE_LOGICAL_VOLUME (udisks_logical_volume_get_type ())
#define UDISKS_LOGICAL_VOLUME(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_LOGICAL_VOLUME, UDisksLogicalVolume))
#define UDISKS_IS_LOGICAL_VOLUME(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_LOGICAL_VOLUME))
#define UDISKS_LOGICAL_VOLUME_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_LOGICAL_VOLUME, UDisksLogicalVolumeIface))

struct _UDisksLogicalVolume;
typedef struct _UDisksLogicalVolume UDisksLogicalVolume;
typedef struct _UDisksLogicalVolumeIface UDisksLogicalVolumeIface;

struct _UDisksLogicalVolumeIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_activate) (
    UDisksLogicalVolume *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_create_snapshot) (
    UDisksLogicalVolume *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_name,
    guint64 arg_size,
    GVariant *arg_options);

  gboolean (*handle_deactivate) (
    UDisksLogicalVolume *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_delete) (
    UDisksLogicalVolume *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_rename) (
    UDisksLogicalVolume *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_new_name,
    GVariant *arg_options);

  gboolean (*handle_resize) (
    UDisksLogicalVolume *object,
    GDBusMethodInvocation *invocation,
    guint64 arg_new_size,
    GVariant *arg_options);

  gboolean  (*get_active) (UDisksLogicalVolume *object);

  GVariant * (*get_child_configuration) (UDisksLogicalVolume *object);

  gdouble  (*get_data_allocated_ratio) (UDisksLogicalVolume *object);

  gdouble  (*get_metadata_allocated_ratio) (UDisksLogicalVolume *object);

  const gchar * (*get_name) (UDisksLogicalVolume *object);

  const gchar * (*get_origin) (UDisksLogicalVolume *object);

  guint64  (*get_size) (UDisksLogicalVolume *object);

  const gchar * (*get_thin_pool) (UDisksLogicalVolume *object);

  const gchar * (*get_type_) (UDisksLogicalVolume *object);

  const gchar * (*get_uuid) (UDisksLogicalVolume *object);

  const gchar * (*get_volume_group) (UDisksLogicalVolume *object);

  gboolean (*handle_cache_attach) (
    UDisksLogicalVolume *object,
    GDBusMethodInvocation *invocation,
    const gchar *arg_cache_name,
    GVariant *arg_options);

  gboolean (*handle_cache_split) (
    UDisksLogicalVolume *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_cache_detach) (
    UDisksLogicalVolume *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  const gchar * (*get_block_device) (UDisksLogicalVolume *object);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksLogicalVolume, g_object_unref)
#endif

GType udisks_logical_volume_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_logical_volume_interface_info (void);
guint udisks_logical_volume_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_logical_volume_complete_activate (
    UDisksLogicalVolume *object,
    GDBusMethodInvocation *invocation,
    const gchar *result);

void udisks_logical_volume_complete_deactivate (
    UDisksLogicalVolume *object,
    GDBusMethodInvocation *invocation);

void udisks_logical_volume_complete_delete (
    UDisksLogicalVolume *object,
    GDBusMethodInvocation *invocation);

void udisks_logical_volume_complete_rename (
    UDisksLogicalVolume *object,
    GDBusMethodInvocation *invocation,
    const gchar *result);

void udisks_logical_volume_complete_resize (
    UDisksLogicalVolume *object,
    GDBusMethodInvocation *invocation);

void udisks_logical_volume_complete_create_snapshot (
    UDisksLogicalVolume *object,
    GDBusMethodInvocation *invocation,
    const gchar *result);

void udisks_logical_volume_complete_cache_attach (
    UDisksLogicalVolume *object,
    GDBusMethodInvocation *invocation);

void udisks_logical_volume_complete_cache_split (
    UDisksLogicalVolume *object,
    GDBusMethodInvocation *invocation);

void udisks_logical_volume_complete_cache_detach (
    UDisksLogicalVolume *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void udisks_logical_volume_call_activate (
    UDisksLogicalVolume *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_logical_volume_call_activate_finish (
    UDisksLogicalVolume *proxy,
    gchar **out_result,
    GAsyncResult *res,
    GError **error);

gboolean udisks_logical_volume_call_activate_sync (
    UDisksLogicalVolume *proxy,
    GVariant *arg_options,
    gchar **out_result,
    GCancellable *cancellable,
    GError **error);

void udisks_logical_volume_call_deactivate (
    UDisksLogicalVolume *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_logical_volume_call_deactivate_finish (
    UDisksLogicalVolume *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_logical_volume_call_deactivate_sync (
    UDisksLogicalVolume *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_logical_volume_call_delete (
    UDisksLogicalVolume *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_logical_volume_call_delete_finish (
    UDisksLogicalVolume *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_logical_volume_call_delete_sync (
    UDisksLogicalVolume *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_logical_volume_call_rename (
    UDisksLogicalVolume *proxy,
    const gchar *arg_new_name,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_logical_volume_call_rename_finish (
    UDisksLogicalVolume *proxy,
    gchar **out_result,
    GAsyncResult *res,
    GError **error);

gboolean udisks_logical_volume_call_rename_sync (
    UDisksLogicalVolume *proxy,
    const gchar *arg_new_name,
    GVariant *arg_options,
    gchar **out_result,
    GCancellable *cancellable,
    GError **error);

void udisks_logical_volume_call_resize (
    UDisksLogicalVolume *proxy,
    guint64 arg_new_size,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_logical_volume_call_resize_finish (
    UDisksLogicalVolume *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_logical_volume_call_resize_sync (
    UDisksLogicalVolume *proxy,
    guint64 arg_new_size,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_logical_volume_call_create_snapshot (
    UDisksLogicalVolume *proxy,
    const gchar *arg_name,
    guint64 arg_size,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_logical_volume_call_create_snapshot_finish (
    UDisksLogicalVolume *proxy,
    gchar **out_result,
    GAsyncResult *res,
    GError **error);

gboolean udisks_logical_volume_call_create_snapshot_sync (
    UDisksLogicalVolume *proxy,
    const gchar *arg_name,
    guint64 arg_size,
    GVariant *arg_options,
    gchar **out_result,
    GCancellable *cancellable,
    GError **error);

void udisks_logical_volume_call_cache_attach (
    UDisksLogicalVolume *proxy,
    const gchar *arg_cache_name,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_logical_volume_call_cache_attach_finish (
    UDisksLogicalVolume *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_logical_volume_call_cache_attach_sync (
    UDisksLogicalVolume *proxy,
    const gchar *arg_cache_name,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_logical_volume_call_cache_split (
    UDisksLogicalVolume *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_logical_volume_call_cache_split_finish (
    UDisksLogicalVolume *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_logical_volume_call_cache_split_sync (
    UDisksLogicalVolume *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_logical_volume_call_cache_detach (
    UDisksLogicalVolume *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_logical_volume_call_cache_detach_finish (
    UDisksLogicalVolume *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_logical_volume_call_cache_detach_sync (
    UDisksLogicalVolume *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
const gchar *udisks_logical_volume_get_volume_group (UDisksLogicalVolume *object);
gchar *udisks_logical_volume_dup_volume_group (UDisksLogicalVolume *object);
void udisks_logical_volume_set_volume_group (UDisksLogicalVolume *object, const gchar *value);

const gchar *udisks_logical_volume_get_name (UDisksLogicalVolume *object);
gchar *udisks_logical_volume_dup_name (UDisksLogicalVolume *object);
void udisks_logical_volume_set_name (UDisksLogicalVolume *object, const gchar *value);

gboolean udisks_logical_volume_get_active (UDisksLogicalVolume *object);
void udisks_logical_volume_set_active (UDisksLogicalVolume *object, gboolean value);

const gchar *udisks_logical_volume_get_uuid (UDisksLogicalVolume *object);
gchar *udisks_logical_volume_dup_uuid (UDisksLogicalVolume *object);
void udisks_logical_volume_set_uuid (UDisksLogicalVolume *object, const gchar *value);

guint64 udisks_logical_volume_get_size (UDisksLogicalVolume *object);
void udisks_logical_volume_set_size (UDisksLogicalVolume *object, guint64 value);

gdouble udisks_logical_volume_get_data_allocated_ratio (UDisksLogicalVolume *object);
void udisks_logical_volume_set_data_allocated_ratio (UDisksLogicalVolume *object, gdouble value);

gdouble udisks_logical_volume_get_metadata_allocated_ratio (UDisksLogicalVolume *object);
void udisks_logical_volume_set_metadata_allocated_ratio (UDisksLogicalVolume *object, gdouble value);

const gchar *udisks_logical_volume_get_type_ (UDisksLogicalVolume *object);
gchar *udisks_logical_volume_dup_type_ (UDisksLogicalVolume *object);
void udisks_logical_volume_set_type_ (UDisksLogicalVolume *object, const gchar *value);

const gchar *udisks_logical_volume_get_thin_pool (UDisksLogicalVolume *object);
gchar *udisks_logical_volume_dup_thin_pool (UDisksLogicalVolume *object);
void udisks_logical_volume_set_thin_pool (UDisksLogicalVolume *object, const gchar *value);

const gchar *udisks_logical_volume_get_origin (UDisksLogicalVolume *object);
gchar *udisks_logical_volume_dup_origin (UDisksLogicalVolume *object);
void udisks_logical_volume_set_origin (UDisksLogicalVolume *object, const gchar *value);

GVariant *udisks_logical_volume_get_child_configuration (UDisksLogicalVolume *object);
GVariant *udisks_logical_volume_dup_child_configuration (UDisksLogicalVolume *object);
void udisks_logical_volume_set_child_configuration (UDisksLogicalVolume *object, GVariant *value);

const gchar *udisks_logical_volume_get_block_device (UDisksLogicalVolume *object);
gchar *udisks_logical_volume_dup_block_device (UDisksLogicalVolume *object);
void udisks_logical_volume_set_block_device (UDisksLogicalVolume *object, const gchar *value);


/* ---- */

#define UDISKS_TYPE_LOGICAL_VOLUME_PROXY (udisks_logical_volume_proxy_get_type ())
#define UDISKS_LOGICAL_VOLUME_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_LOGICAL_VOLUME_PROXY, UDisksLogicalVolumeProxy))
#define UDISKS_LOGICAL_VOLUME_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_LOGICAL_VOLUME_PROXY, UDisksLogicalVolumeProxyClass))
#define UDISKS_LOGICAL_VOLUME_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_LOGICAL_VOLUME_PROXY, UDisksLogicalVolumeProxyClass))
#define UDISKS_IS_LOGICAL_VOLUME_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_LOGICAL_VOLUME_PROXY))
#define UDISKS_IS_LOGICAL_VOLUME_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_LOGICAL_VOLUME_PROXY))

typedef struct _UDisksLogicalVolumeProxy UDisksLogicalVolumeProxy;
typedef struct _UDisksLogicalVolumeProxyClass UDisksLogicalVolumeProxyClass;
typedef struct _UDisksLogicalVolumeProxyPrivate UDisksLogicalVolumeProxyPrivate;

struct _UDisksLogicalVolumeProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksLogicalVolumeProxyPrivate *priv;
};

struct _UDisksLogicalVolumeProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_logical_volume_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksLogicalVolumeProxy, g_object_unref)
#endif

void udisks_logical_volume_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksLogicalVolume *udisks_logical_volume_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksLogicalVolume *udisks_logical_volume_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_logical_volume_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksLogicalVolume *udisks_logical_volume_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksLogicalVolume *udisks_logical_volume_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_LOGICAL_VOLUME_SKELETON (udisks_logical_volume_skeleton_get_type ())
#define UDISKS_LOGICAL_VOLUME_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_LOGICAL_VOLUME_SKELETON, UDisksLogicalVolumeSkeleton))
#define UDISKS_LOGICAL_VOLUME_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_LOGICAL_VOLUME_SKELETON, UDisksLogicalVolumeSkeletonClass))
#define UDISKS_LOGICAL_VOLUME_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_LOGICAL_VOLUME_SKELETON, UDisksLogicalVolumeSkeletonClass))
#define UDISKS_IS_LOGICAL_VOLUME_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_LOGICAL_VOLUME_SKELETON))
#define UDISKS_IS_LOGICAL_VOLUME_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_LOGICAL_VOLUME_SKELETON))

typedef struct _UDisksLogicalVolumeSkeleton UDisksLogicalVolumeSkeleton;
typedef struct _UDisksLogicalVolumeSkeletonClass UDisksLogicalVolumeSkeletonClass;
typedef struct _UDisksLogicalVolumeSkeletonPrivate UDisksLogicalVolumeSkeletonPrivate;

struct _UDisksLogicalVolumeSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksLogicalVolumeSkeletonPrivate *priv;
};

struct _UDisksLogicalVolumeSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_logical_volume_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksLogicalVolumeSkeleton, g_object_unref)
#endif

UDisksLogicalVolume *udisks_logical_volume_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.VDOVolume */

#define UDISKS_TYPE_VDO_VOLUME (udisks_vdo_volume_get_type ())
#define UDISKS_VDO_VOLUME(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_VDO_VOLUME, UDisksVDOVolume))
#define UDISKS_IS_VDO_VOLUME(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_VDO_VOLUME))
#define UDISKS_VDO_VOLUME_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_VDO_VOLUME, UDisksVDOVolumeIface))

struct _UDisksVDOVolume;
typedef struct _UDisksVDOVolume UDisksVDOVolume;
typedef struct _UDisksVDOVolumeIface UDisksVDOVolumeIface;

struct _UDisksVDOVolumeIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_enable_compression) (
    UDisksVDOVolume *object,
    GDBusMethodInvocation *invocation,
    gboolean arg_enable,
    GVariant *arg_options);

  gboolean (*handle_enable_deduplication) (
    UDisksVDOVolume *object,
    GDBusMethodInvocation *invocation,
    gboolean arg_enable,
    GVariant *arg_options);

  gboolean (*handle_get_statistics) (
    UDisksVDOVolume *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_resize_logical) (
    UDisksVDOVolume *object,
    GDBusMethodInvocation *invocation,
    guint64 arg_size,
    GVariant *arg_options);

  gboolean (*handle_resize_physical) (
    UDisksVDOVolume *object,
    GDBusMethodInvocation *invocation,
    guint64 arg_size,
    GVariant *arg_options);

  gboolean  (*get_compression) (UDisksVDOVolume *object);

  const gchar * (*get_compression_state) (UDisksVDOVolume *object);

  gboolean  (*get_deduplication) (UDisksVDOVolume *object);

  const gchar * (*get_index_state) (UDisksVDOVolume *object);

  const gchar * (*get_operating_mode) (UDisksVDOVolume *object);

  guint64  (*get_used_size) (UDisksVDOVolume *object);

  const gchar * (*get_vdo_pool) (UDisksVDOVolume *object);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksVDOVolume, g_object_unref)
#endif

GType udisks_vdo_volume_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_vdo_volume_interface_info (void);
guint udisks_vdo_volume_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_vdo_volume_complete_enable_compression (
    UDisksVDOVolume *object,
    GDBusMethodInvocation *invocation);

void udisks_vdo_volume_complete_enable_deduplication (
    UDisksVDOVolume *object,
    GDBusMethodInvocation *invocation);

void udisks_vdo_volume_complete_resize_logical (
    UDisksVDOVolume *object,
    GDBusMethodInvocation *invocation);

void udisks_vdo_volume_complete_resize_physical (
    UDisksVDOVolume *object,
    GDBusMethodInvocation *invocation);

void udisks_vdo_volume_complete_get_statistics (
    UDisksVDOVolume *object,
    GDBusMethodInvocation *invocation,
    GVariant *stats);



/* D-Bus method calls: */
void udisks_vdo_volume_call_enable_compression (
    UDisksVDOVolume *proxy,
    gboolean arg_enable,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_vdo_volume_call_enable_compression_finish (
    UDisksVDOVolume *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_vdo_volume_call_enable_compression_sync (
    UDisksVDOVolume *proxy,
    gboolean arg_enable,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_vdo_volume_call_enable_deduplication (
    UDisksVDOVolume *proxy,
    gboolean arg_enable,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_vdo_volume_call_enable_deduplication_finish (
    UDisksVDOVolume *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_vdo_volume_call_enable_deduplication_sync (
    UDisksVDOVolume *proxy,
    gboolean arg_enable,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_vdo_volume_call_resize_logical (
    UDisksVDOVolume *proxy,
    guint64 arg_size,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_vdo_volume_call_resize_logical_finish (
    UDisksVDOVolume *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_vdo_volume_call_resize_logical_sync (
    UDisksVDOVolume *proxy,
    guint64 arg_size,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_vdo_volume_call_resize_physical (
    UDisksVDOVolume *proxy,
    guint64 arg_size,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_vdo_volume_call_resize_physical_finish (
    UDisksVDOVolume *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_vdo_volume_call_resize_physical_sync (
    UDisksVDOVolume *proxy,
    guint64 arg_size,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_vdo_volume_call_get_statistics (
    UDisksVDOVolume *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_vdo_volume_call_get_statistics_finish (
    UDisksVDOVolume *proxy,
    GVariant **out_stats,
    GAsyncResult *res,
    GError **error);

gboolean udisks_vdo_volume_call_get_statistics_sync (
    UDisksVDOVolume *proxy,
    GVariant *arg_options,
    GVariant **out_stats,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
const gchar *udisks_vdo_volume_get_vdo_pool (UDisksVDOVolume *object);
gchar *udisks_vdo_volume_dup_vdo_pool (UDisksVDOVolume *object);
void udisks_vdo_volume_set_vdo_pool (UDisksVDOVolume *object, const gchar *value);

const gchar *udisks_vdo_volume_get_operating_mode (UDisksVDOVolume *object);
gchar *udisks_vdo_volume_dup_operating_mode (UDisksVDOVolume *object);
void udisks_vdo_volume_set_operating_mode (UDisksVDOVolume *object, const gchar *value);

const gchar *udisks_vdo_volume_get_compression_state (UDisksVDOVolume *object);
gchar *udisks_vdo_volume_dup_compression_state (UDisksVDOVolume *object);
void udisks_vdo_volume_set_compression_state (UDisksVDOVolume *object, const gchar *value);

const gchar *udisks_vdo_volume_get_index_state (UDisksVDOVolume *object);
gchar *udisks_vdo_volume_dup_index_state (UDisksVDOVolume *object);
void udisks_vdo_volume_set_index_state (UDisksVDOVolume *object, const gchar *value);

guint64 udisks_vdo_volume_get_used_size (UDisksVDOVolume *object);
void udisks_vdo_volume_set_used_size (UDisksVDOVolume *object, guint64 value);

gboolean udisks_vdo_volume_get_compression (UDisksVDOVolume *object);
void udisks_vdo_volume_set_compression (UDisksVDOVolume *object, gboolean value);

gboolean udisks_vdo_volume_get_deduplication (UDisksVDOVolume *object);
void udisks_vdo_volume_set_deduplication (UDisksVDOVolume *object, gboolean value);


/* ---- */

#define UDISKS_TYPE_VDO_VOLUME_PROXY (udisks_vdo_volume_proxy_get_type ())
#define UDISKS_VDO_VOLUME_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_VDO_VOLUME_PROXY, UDisksVDOVolumeProxy))
#define UDISKS_VDO_VOLUME_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_VDO_VOLUME_PROXY, UDisksVDOVolumeProxyClass))
#define UDISKS_VDO_VOLUME_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_VDO_VOLUME_PROXY, UDisksVDOVolumeProxyClass))
#define UDISKS_IS_VDO_VOLUME_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_VDO_VOLUME_PROXY))
#define UDISKS_IS_VDO_VOLUME_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_VDO_VOLUME_PROXY))

typedef struct _UDisksVDOVolumeProxy UDisksVDOVolumeProxy;
typedef struct _UDisksVDOVolumeProxyClass UDisksVDOVolumeProxyClass;
typedef struct _UDisksVDOVolumeProxyPrivate UDisksVDOVolumeProxyPrivate;

struct _UDisksVDOVolumeProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksVDOVolumeProxyPrivate *priv;
};

struct _UDisksVDOVolumeProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_vdo_volume_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksVDOVolumeProxy, g_object_unref)
#endif

void udisks_vdo_volume_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksVDOVolume *udisks_vdo_volume_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksVDOVolume *udisks_vdo_volume_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_vdo_volume_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksVDOVolume *udisks_vdo_volume_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksVDOVolume *udisks_vdo_volume_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_VDO_VOLUME_SKELETON (udisks_vdo_volume_skeleton_get_type ())
#define UDISKS_VDO_VOLUME_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_VDO_VOLUME_SKELETON, UDisksVDOVolumeSkeleton))
#define UDISKS_VDO_VOLUME_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_VDO_VOLUME_SKELETON, UDisksVDOVolumeSkeletonClass))
#define UDISKS_VDO_VOLUME_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_VDO_VOLUME_SKELETON, UDisksVDOVolumeSkeletonClass))
#define UDISKS_IS_VDO_VOLUME_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_VDO_VOLUME_SKELETON))
#define UDISKS_IS_VDO_VOLUME_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_VDO_VOLUME_SKELETON))

typedef struct _UDisksVDOVolumeSkeleton UDisksVDOVolumeSkeleton;
typedef struct _UDisksVDOVolumeSkeletonClass UDisksVDOVolumeSkeletonClass;
typedef struct _UDisksVDOVolumeSkeletonPrivate UDisksVDOVolumeSkeletonPrivate;

struct _UDisksVDOVolumeSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksVDOVolumeSkeletonPrivate *priv;
};

struct _UDisksVDOVolumeSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_vdo_volume_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksVDOVolumeSkeleton, g_object_unref)
#endif

UDisksVDOVolume *udisks_vdo_volume_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Manager.ZRAM */

#define UDISKS_TYPE_MANAGER_ZRAM (udisks_manager_zram_get_type ())
#define UDISKS_MANAGER_ZRAM(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_MANAGER_ZRAM, UDisksManagerZRAM))
#define UDISKS_IS_MANAGER_ZRAM(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_MANAGER_ZRAM))
#define UDISKS_MANAGER_ZRAM_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_MANAGER_ZRAM, UDisksManagerZRAMIface))

struct _UDisksManagerZRAM;
typedef struct _UDisksManagerZRAM UDisksManagerZRAM;
typedef struct _UDisksManagerZRAMIface UDisksManagerZRAMIface;

struct _UDisksManagerZRAMIface
{
  GTypeInterface parent_iface;

  gboolean (*handle_create_devices) (
    UDisksManagerZRAM *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_sizes,
    GVariant *arg_num_streams,
    GVariant *arg_options);

  gboolean (*handle_destroy_devices) (
    UDisksManagerZRAM *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksManagerZRAM, g_object_unref)
#endif

GType udisks_manager_zram_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_manager_zram_interface_info (void);
guint udisks_manager_zram_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_manager_zram_complete_create_devices (
    UDisksManagerZRAM *object,
    GDBusMethodInvocation *invocation,
    const gchar *const *zrams);

void udisks_manager_zram_complete_destroy_devices (
    UDisksManagerZRAM *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void udisks_manager_zram_call_create_devices (
    UDisksManagerZRAM *proxy,
    GVariant *arg_sizes,
    GVariant *arg_num_streams,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_manager_zram_call_create_devices_finish (
    UDisksManagerZRAM *proxy,
    gchar ***out_zrams,
    GAsyncResult *res,
    GError **error);

gboolean udisks_manager_zram_call_create_devices_sync (
    UDisksManagerZRAM *proxy,
    GVariant *arg_sizes,
    GVariant *arg_num_streams,
    GVariant *arg_options,
    gchar ***out_zrams,
    GCancellable *cancellable,
    GError **error);

void udisks_manager_zram_call_destroy_devices (
    UDisksManagerZRAM *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_manager_zram_call_destroy_devices_finish (
    UDisksManagerZRAM *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_manager_zram_call_destroy_devices_sync (
    UDisksManagerZRAM *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);



/* ---- */

#define UDISKS_TYPE_MANAGER_ZRAM_PROXY (udisks_manager_zram_proxy_get_type ())
#define UDISKS_MANAGER_ZRAM_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_MANAGER_ZRAM_PROXY, UDisksManagerZRAMProxy))
#define UDISKS_MANAGER_ZRAM_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_MANAGER_ZRAM_PROXY, UDisksManagerZRAMProxyClass))
#define UDISKS_MANAGER_ZRAM_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_MANAGER_ZRAM_PROXY, UDisksManagerZRAMProxyClass))
#define UDISKS_IS_MANAGER_ZRAM_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_MANAGER_ZRAM_PROXY))
#define UDISKS_IS_MANAGER_ZRAM_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_MANAGER_ZRAM_PROXY))

typedef struct _UDisksManagerZRAMProxy UDisksManagerZRAMProxy;
typedef struct _UDisksManagerZRAMProxyClass UDisksManagerZRAMProxyClass;
typedef struct _UDisksManagerZRAMProxyPrivate UDisksManagerZRAMProxyPrivate;

struct _UDisksManagerZRAMProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksManagerZRAMProxyPrivate *priv;
};

struct _UDisksManagerZRAMProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_manager_zram_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksManagerZRAMProxy, g_object_unref)
#endif

void udisks_manager_zram_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksManagerZRAM *udisks_manager_zram_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksManagerZRAM *udisks_manager_zram_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_manager_zram_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksManagerZRAM *udisks_manager_zram_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksManagerZRAM *udisks_manager_zram_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_MANAGER_ZRAM_SKELETON (udisks_manager_zram_skeleton_get_type ())
#define UDISKS_MANAGER_ZRAM_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_MANAGER_ZRAM_SKELETON, UDisksManagerZRAMSkeleton))
#define UDISKS_MANAGER_ZRAM_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_MANAGER_ZRAM_SKELETON, UDisksManagerZRAMSkeletonClass))
#define UDISKS_MANAGER_ZRAM_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_MANAGER_ZRAM_SKELETON, UDisksManagerZRAMSkeletonClass))
#define UDISKS_IS_MANAGER_ZRAM_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_MANAGER_ZRAM_SKELETON))
#define UDISKS_IS_MANAGER_ZRAM_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_MANAGER_ZRAM_SKELETON))

typedef struct _UDisksManagerZRAMSkeleton UDisksManagerZRAMSkeleton;
typedef struct _UDisksManagerZRAMSkeletonClass UDisksManagerZRAMSkeletonClass;
typedef struct _UDisksManagerZRAMSkeletonPrivate UDisksManagerZRAMSkeletonPrivate;

struct _UDisksManagerZRAMSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksManagerZRAMSkeletonPrivate *priv;
};

struct _UDisksManagerZRAMSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_manager_zram_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksManagerZRAMSkeleton, g_object_unref)
#endif

UDisksManagerZRAM *udisks_manager_zram_skeleton_new (void);


/* ------------------------------------------------------------------------ */
/* Declarations for org.freedesktop.UDisks2.Block.ZRAM */

#define UDISKS_TYPE_BLOCK_ZRAM (udisks_block_zram_get_type ())
#define UDISKS_BLOCK_ZRAM(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_BLOCK_ZRAM, UDisksBlockZRAM))
#define UDISKS_IS_BLOCK_ZRAM(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_BLOCK_ZRAM))
#define UDISKS_BLOCK_ZRAM_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_BLOCK_ZRAM, UDisksBlockZRAMIface))

struct _UDisksBlockZRAM;
typedef struct _UDisksBlockZRAM UDisksBlockZRAM;
typedef struct _UDisksBlockZRAMIface UDisksBlockZRAMIface;

struct _UDisksBlockZRAMIface
{
  GTypeInterface parent_iface;


  gboolean (*handle_activate) (
    UDisksBlockZRAM *object,
    GDBusMethodInvocation *invocation,
    gint arg_priority,
    GVariant *arg_options);

  gboolean (*handle_activate_labeled) (
    UDisksBlockZRAM *object,
    GDBusMethodInvocation *invocation,
    gint arg_priority,
    const gchar *arg_label,
    GVariant *arg_options);

  gboolean (*handle_deactivate) (
    UDisksBlockZRAM *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean (*handle_refresh) (
    UDisksBlockZRAM *object,
    GDBusMethodInvocation *invocation,
    GVariant *arg_options);

  gboolean  (*get_active) (UDisksBlockZRAM *object);

  const gchar * (*get_comp_algorithm) (UDisksBlockZRAM *object);

  guint64  (*get_compr_data_size) (UDisksBlockZRAM *object);

  guint64  (*get_disksize) (UDisksBlockZRAM *object);

  guint64  (*get_invalid_io) (UDisksBlockZRAM *object);

  guint64  (*get_max_comp_streams) (UDisksBlockZRAM *object);

  guint64  (*get_mem_used_total) (UDisksBlockZRAM *object);

  guint64  (*get_num_reads) (UDisksBlockZRAM *object);

  guint64  (*get_num_writes) (UDisksBlockZRAM *object);

  guint64  (*get_orig_data_size) (UDisksBlockZRAM *object);

  guint64  (*get_zero_pages) (UDisksBlockZRAM *object);

};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksBlockZRAM, g_object_unref)
#endif

GType udisks_block_zram_get_type (void) G_GNUC_CONST;

GDBusInterfaceInfo *udisks_block_zram_interface_info (void);
guint udisks_block_zram_override_properties (GObjectClass *klass, guint property_id_begin);


/* D-Bus method call completion functions: */
void udisks_block_zram_complete_refresh (
    UDisksBlockZRAM *object,
    GDBusMethodInvocation *invocation);

void udisks_block_zram_complete_activate (
    UDisksBlockZRAM *object,
    GDBusMethodInvocation *invocation);

void udisks_block_zram_complete_activate_labeled (
    UDisksBlockZRAM *object,
    GDBusMethodInvocation *invocation);

void udisks_block_zram_complete_deactivate (
    UDisksBlockZRAM *object,
    GDBusMethodInvocation *invocation);



/* D-Bus method calls: */
void udisks_block_zram_call_refresh (
    UDisksBlockZRAM *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_block_zram_call_refresh_finish (
    UDisksBlockZRAM *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_block_zram_call_refresh_sync (
    UDisksBlockZRAM *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_block_zram_call_activate (
    UDisksBlockZRAM *proxy,
    gint arg_priority,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_block_zram_call_activate_finish (
    UDisksBlockZRAM *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_block_zram_call_activate_sync (
    UDisksBlockZRAM *proxy,
    gint arg_priority,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_block_zram_call_activate_labeled (
    UDisksBlockZRAM *proxy,
    gint arg_priority,
    const gchar *arg_label,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_block_zram_call_activate_labeled_finish (
    UDisksBlockZRAM *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_block_zram_call_activate_labeled_sync (
    UDisksBlockZRAM *proxy,
    gint arg_priority,
    const gchar *arg_label,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);

void udisks_block_zram_call_deactivate (
    UDisksBlockZRAM *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data);

gboolean udisks_block_zram_call_deactivate_finish (
    UDisksBlockZRAM *proxy,
    GAsyncResult *res,
    GError **error);

gboolean udisks_block_zram_call_deactivate_sync (
    UDisksBlockZRAM *proxy,
    GVariant *arg_options,
    GCancellable *cancellable,
    GError **error);



/* D-Bus property accessors: */
guint64 udisks_block_zram_get_disksize (UDisksBlockZRAM *object);
void udisks_block_zram_set_disksize (UDisksBlockZRAM *object, guint64 value);

guint64 udisks_block_zram_get_max_comp_streams (UDisksBlockZRAM *object);
void udisks_block_zram_set_max_comp_streams (UDisksBlockZRAM *object, guint64 value);

const gchar *udisks_block_zram_get_comp_algorithm (UDisksBlockZRAM *object);
gchar *udisks_block_zram_dup_comp_algorithm (UDisksBlockZRAM *object);
void udisks_block_zram_set_comp_algorithm (UDisksBlockZRAM *object, const gchar *value);

gboolean udisks_block_zram_get_active (UDisksBlockZRAM *object);
void udisks_block_zram_set_active (UDisksBlockZRAM *object, gboolean value);

guint64 udisks_block_zram_get_num_reads (UDisksBlockZRAM *object);
void udisks_block_zram_set_num_reads (UDisksBlockZRAM *object, guint64 value);

guint64 udisks_block_zram_get_num_writes (UDisksBlockZRAM *object);
void udisks_block_zram_set_num_writes (UDisksBlockZRAM *object, guint64 value);

guint64 udisks_block_zram_get_invalid_io (UDisksBlockZRAM *object);
void udisks_block_zram_set_invalid_io (UDisksBlockZRAM *object, guint64 value);

guint64 udisks_block_zram_get_zero_pages (UDisksBlockZRAM *object);
void udisks_block_zram_set_zero_pages (UDisksBlockZRAM *object, guint64 value);

guint64 udisks_block_zram_get_orig_data_size (UDisksBlockZRAM *object);
void udisks_block_zram_set_orig_data_size (UDisksBlockZRAM *object, guint64 value);

guint64 udisks_block_zram_get_compr_data_size (UDisksBlockZRAM *object);
void udisks_block_zram_set_compr_data_size (UDisksBlockZRAM *object, guint64 value);

guint64 udisks_block_zram_get_mem_used_total (UDisksBlockZRAM *object);
void udisks_block_zram_set_mem_used_total (UDisksBlockZRAM *object, guint64 value);


/* ---- */

#define UDISKS_TYPE_BLOCK_ZRAM_PROXY (udisks_block_zram_proxy_get_type ())
#define UDISKS_BLOCK_ZRAM_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_BLOCK_ZRAM_PROXY, UDisksBlockZRAMProxy))
#define UDISKS_BLOCK_ZRAM_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_BLOCK_ZRAM_PROXY, UDisksBlockZRAMProxyClass))
#define UDISKS_BLOCK_ZRAM_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_BLOCK_ZRAM_PROXY, UDisksBlockZRAMProxyClass))
#define UDISKS_IS_BLOCK_ZRAM_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_BLOCK_ZRAM_PROXY))
#define UDISKS_IS_BLOCK_ZRAM_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_BLOCK_ZRAM_PROXY))

typedef struct _UDisksBlockZRAMProxy UDisksBlockZRAMProxy;
typedef struct _UDisksBlockZRAMProxyClass UDisksBlockZRAMProxyClass;
typedef struct _UDisksBlockZRAMProxyPrivate UDisksBlockZRAMProxyPrivate;

struct _UDisksBlockZRAMProxy
{
  /*< private >*/
  GDBusProxy parent_instance;
  UDisksBlockZRAMProxyPrivate *priv;
};

struct _UDisksBlockZRAMProxyClass
{
  GDBusProxyClass parent_class;
};

GType udisks_block_zram_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksBlockZRAMProxy, g_object_unref)
#endif

void udisks_block_zram_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksBlockZRAM *udisks_block_zram_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksBlockZRAM *udisks_block_zram_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);

void udisks_block_zram_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data);
UDisksBlockZRAM *udisks_block_zram_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
UDisksBlockZRAM *udisks_block_zram_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error);


/* ---- */

#define UDISKS_TYPE_BLOCK_ZRAM_SKELETON (udisks_block_zram_skeleton_get_type ())
#define UDISKS_BLOCK_ZRAM_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_BLOCK_ZRAM_SKELETON, UDisksBlockZRAMSkeleton))
#define UDISKS_BLOCK_ZRAM_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_BLOCK_ZRAM_SKELETON, UDisksBlockZRAMSkeletonClass))
#define UDISKS_BLOCK_ZRAM_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_BLOCK_ZRAM_SKELETON, UDisksBlockZRAMSkeletonClass))
#define UDISKS_IS_BLOCK_ZRAM_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_BLOCK_ZRAM_SKELETON))
#define UDISKS_IS_BLOCK_ZRAM_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_BLOCK_ZRAM_SKELETON))

typedef struct _UDisksBlockZRAMSkeleton UDisksBlockZRAMSkeleton;
typedef struct _UDisksBlockZRAMSkeletonClass UDisksBlockZRAMSkeletonClass;
typedef struct _UDisksBlockZRAMSkeletonPrivate UDisksBlockZRAMSkeletonPrivate;

struct _UDisksBlockZRAMSkeleton
{
  /*< private >*/
  GDBusInterfaceSkeleton parent_instance;
  UDisksBlockZRAMSkeletonPrivate *priv;
};

struct _UDisksBlockZRAMSkeletonClass
{
  GDBusInterfaceSkeletonClass parent_class;
};

GType udisks_block_zram_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksBlockZRAMSkeleton, g_object_unref)
#endif

UDisksBlockZRAM *udisks_block_zram_skeleton_new (void);


/* ---- */

#define UDISKS_TYPE_OBJECT (udisks_object_get_type ())
#define UDISKS_OBJECT(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_OBJECT, UDisksObject))
#define UDISKS_IS_OBJECT(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_OBJECT))
#define UDISKS_OBJECT_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), UDISKS_TYPE_OBJECT, UDisksObject))

struct _UDisksObject;
typedef struct _UDisksObject UDisksObject;
typedef struct _UDisksObjectIface UDisksObjectIface;

struct _UDisksObjectIface
{
  GTypeInterface parent_iface;
};

GType udisks_object_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksObject, g_object_unref)
#endif

UDisksManager *udisks_object_get_manager (UDisksObject *object);
UDisksDrive *udisks_object_get_drive (UDisksObject *object);
UDisksDriveAta *udisks_object_get_drive_ata (UDisksObject *object);
UDisksBlock *udisks_object_get_block (UDisksObject *object);
UDisksPartitionTable *udisks_object_get_partition_table (UDisksObject *object);
UDisksPartition *udisks_object_get_partition (UDisksObject *object);
UDisksFilesystem *udisks_object_get_filesystem (UDisksObject *object);
UDisksSwapspace *udisks_object_get_swapspace (UDisksObject *object);
UDisksEncrypted *udisks_object_get_encrypted (UDisksObject *object);
UDisksLoop *udisks_object_get_loop (UDisksObject *object);
UDisksMDRaid *udisks_object_get_mdraid (UDisksObject *object);
UDisksJob *udisks_object_get_job (UDisksObject *object);
UDisksManagerBcache *udisks_object_get_manager_bcache (UDisksObject *object);
UDisksBlockBcache *udisks_object_get_block_bcache (UDisksObject *object);
UDisksManagerBTRFS *udisks_object_get_manager_btrfs (UDisksObject *object);
UDisksFilesystemBTRFS *udisks_object_get_filesystem_btrfs (UDisksObject *object);
UDisksManagerLVM2 *udisks_object_get_manager_lvm2 (UDisksObject *object);
UDisksBlockLVM2 *udisks_object_get_block_lvm2 (UDisksObject *object);
UDisksPhysicalVolume *udisks_object_get_physical_volume (UDisksObject *object);
UDisksVolumeGroup *udisks_object_get_volume_group (UDisksObject *object);
UDisksLogicalVolume *udisks_object_get_logical_volume (UDisksObject *object);
UDisksVDOVolume *udisks_object_get_vdo_volume (UDisksObject *object);
UDisksManagerZRAM *udisks_object_get_manager_zram (UDisksObject *object);
UDisksBlockZRAM *udisks_object_get_block_zram (UDisksObject *object);
UDisksManager *udisks_object_peek_manager (UDisksObject *object);
UDisksDrive *udisks_object_peek_drive (UDisksObject *object);
UDisksDriveAta *udisks_object_peek_drive_ata (UDisksObject *object);
UDisksBlock *udisks_object_peek_block (UDisksObject *object);
UDisksPartitionTable *udisks_object_peek_partition_table (UDisksObject *object);
UDisksPartition *udisks_object_peek_partition (UDisksObject *object);
UDisksFilesystem *udisks_object_peek_filesystem (UDisksObject *object);
UDisksSwapspace *udisks_object_peek_swapspace (UDisksObject *object);
UDisksEncrypted *udisks_object_peek_encrypted (UDisksObject *object);
UDisksLoop *udisks_object_peek_loop (UDisksObject *object);
UDisksMDRaid *udisks_object_peek_mdraid (UDisksObject *object);
UDisksJob *udisks_object_peek_job (UDisksObject *object);
UDisksManagerBcache *udisks_object_peek_manager_bcache (UDisksObject *object);
UDisksBlockBcache *udisks_object_peek_block_bcache (UDisksObject *object);
UDisksManagerBTRFS *udisks_object_peek_manager_btrfs (UDisksObject *object);
UDisksFilesystemBTRFS *udisks_object_peek_filesystem_btrfs (UDisksObject *object);
UDisksManagerLVM2 *udisks_object_peek_manager_lvm2 (UDisksObject *object);
UDisksBlockLVM2 *udisks_object_peek_block_lvm2 (UDisksObject *object);
UDisksPhysicalVolume *udisks_object_peek_physical_volume (UDisksObject *object);
UDisksVolumeGroup *udisks_object_peek_volume_group (UDisksObject *object);
UDisksLogicalVolume *udisks_object_peek_logical_volume (UDisksObject *object);
UDisksVDOVolume *udisks_object_peek_vdo_volume (UDisksObject *object);
UDisksManagerZRAM *udisks_object_peek_manager_zram (UDisksObject *object);
UDisksBlockZRAM *udisks_object_peek_block_zram (UDisksObject *object);

#define UDISKS_TYPE_OBJECT_PROXY (udisks_object_proxy_get_type ())
#define UDISKS_OBJECT_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_OBJECT_PROXY, UDisksObjectProxy))
#define UDISKS_OBJECT_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_OBJECT_PROXY, UDisksObjectProxyClass))
#define UDISKS_OBJECT_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_OBJECT_PROXY, UDisksObjectProxyClass))
#define UDISKS_IS_OBJECT_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_OBJECT_PROXY))
#define UDISKS_IS_OBJECT_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_OBJECT_PROXY))

typedef struct _UDisksObjectProxy UDisksObjectProxy;
typedef struct _UDisksObjectProxyClass UDisksObjectProxyClass;
typedef struct _UDisksObjectProxyPrivate UDisksObjectProxyPrivate;

struct _UDisksObjectProxy
{
  /*< private >*/
  GDBusObjectProxy parent_instance;
  UDisksObjectProxyPrivate *priv;
};

struct _UDisksObjectProxyClass
{
  GDBusObjectProxyClass parent_class;
};

GType udisks_object_proxy_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksObjectProxy, g_object_unref)
#endif

UDisksObjectProxy *udisks_object_proxy_new (GDBusConnection *connection, const gchar *object_path);

#define UDISKS_TYPE_OBJECT_SKELETON (udisks_object_skeleton_get_type ())
#define UDISKS_OBJECT_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_OBJECT_SKELETON, UDisksObjectSkeleton))
#define UDISKS_OBJECT_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_OBJECT_SKELETON, UDisksObjectSkeletonClass))
#define UDISKS_OBJECT_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_OBJECT_SKELETON, UDisksObjectSkeletonClass))
#define UDISKS_IS_OBJECT_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_OBJECT_SKELETON))
#define UDISKS_IS_OBJECT_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_OBJECT_SKELETON))

typedef struct _UDisksObjectSkeleton UDisksObjectSkeleton;
typedef struct _UDisksObjectSkeletonClass UDisksObjectSkeletonClass;
typedef struct _UDisksObjectSkeletonPrivate UDisksObjectSkeletonPrivate;

struct _UDisksObjectSkeleton
{
  /*< private >*/
  GDBusObjectSkeleton parent_instance;
  UDisksObjectSkeletonPrivate *priv;
};

struct _UDisksObjectSkeletonClass
{
  GDBusObjectSkeletonClass parent_class;
};

GType udisks_object_skeleton_get_type (void) G_GNUC_CONST;

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksObjectSkeleton, g_object_unref)
#endif

UDisksObjectSkeleton *udisks_object_skeleton_new (const gchar *object_path);
void udisks_object_skeleton_set_manager (UDisksObjectSkeleton *object, UDisksManager *interface_);
void udisks_object_skeleton_set_drive (UDisksObjectSkeleton *object, UDisksDrive *interface_);
void udisks_object_skeleton_set_drive_ata (UDisksObjectSkeleton *object, UDisksDriveAta *interface_);
void udisks_object_skeleton_set_block (UDisksObjectSkeleton *object, UDisksBlock *interface_);
void udisks_object_skeleton_set_partition_table (UDisksObjectSkeleton *object, UDisksPartitionTable *interface_);
void udisks_object_skeleton_set_partition (UDisksObjectSkeleton *object, UDisksPartition *interface_);
void udisks_object_skeleton_set_filesystem (UDisksObjectSkeleton *object, UDisksFilesystem *interface_);
void udisks_object_skeleton_set_swapspace (UDisksObjectSkeleton *object, UDisksSwapspace *interface_);
void udisks_object_skeleton_set_encrypted (UDisksObjectSkeleton *object, UDisksEncrypted *interface_);
void udisks_object_skeleton_set_loop (UDisksObjectSkeleton *object, UDisksLoop *interface_);
void udisks_object_skeleton_set_mdraid (UDisksObjectSkeleton *object, UDisksMDRaid *interface_);
void udisks_object_skeleton_set_job (UDisksObjectSkeleton *object, UDisksJob *interface_);
void udisks_object_skeleton_set_manager_bcache (UDisksObjectSkeleton *object, UDisksManagerBcache *interface_);
void udisks_object_skeleton_set_block_bcache (UDisksObjectSkeleton *object, UDisksBlockBcache *interface_);
void udisks_object_skeleton_set_manager_btrfs (UDisksObjectSkeleton *object, UDisksManagerBTRFS *interface_);
void udisks_object_skeleton_set_filesystem_btrfs (UDisksObjectSkeleton *object, UDisksFilesystemBTRFS *interface_);
void udisks_object_skeleton_set_manager_lvm2 (UDisksObjectSkeleton *object, UDisksManagerLVM2 *interface_);
void udisks_object_skeleton_set_block_lvm2 (UDisksObjectSkeleton *object, UDisksBlockLVM2 *interface_);
void udisks_object_skeleton_set_physical_volume (UDisksObjectSkeleton *object, UDisksPhysicalVolume *interface_);
void udisks_object_skeleton_set_volume_group (UDisksObjectSkeleton *object, UDisksVolumeGroup *interface_);
void udisks_object_skeleton_set_logical_volume (UDisksObjectSkeleton *object, UDisksLogicalVolume *interface_);
void udisks_object_skeleton_set_vdo_volume (UDisksObjectSkeleton *object, UDisksVDOVolume *interface_);
void udisks_object_skeleton_set_manager_zram (UDisksObjectSkeleton *object, UDisksManagerZRAM *interface_);
void udisks_object_skeleton_set_block_zram (UDisksObjectSkeleton *object, UDisksBlockZRAM *interface_);

/* ---- */

#define UDISKS_TYPE_OBJECT_MANAGER_CLIENT (udisks_object_manager_client_get_type ())
#define UDISKS_OBJECT_MANAGER_CLIENT(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), UDISKS_TYPE_OBJECT_MANAGER_CLIENT, UDisksObjectManagerClient))
#define UDISKS_OBJECT_MANAGER_CLIENT_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), UDISKS_TYPE_OBJECT_MANAGER_CLIENT, UDisksObjectManagerClientClass))
#define UDISKS_OBJECT_MANAGER_CLIENT_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UDISKS_TYPE_OBJECT_MANAGER_CLIENT, UDisksObjectManagerClientClass))
#define UDISKS_IS_OBJECT_MANAGER_CLIENT(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), UDISKS_TYPE_OBJECT_MANAGER_CLIENT))
#define UDISKS_IS_OBJECT_MANAGER_CLIENT_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), UDISKS_TYPE_OBJECT_MANAGER_CLIENT))

typedef struct _UDisksObjectManagerClient UDisksObjectManagerClient;
typedef struct _UDisksObjectManagerClientClass UDisksObjectManagerClientClass;
typedef struct _UDisksObjectManagerClientPrivate UDisksObjectManagerClientPrivate;

struct _UDisksObjectManagerClient
{
  /*< private >*/
  GDBusObjectManagerClient parent_instance;
  UDisksObjectManagerClientPrivate *priv;
};

struct _UDisksObjectManagerClientClass
{
  GDBusObjectManagerClientClass parent_class;
};

#if GLIB_CHECK_VERSION(2, 44, 0)
G_DEFINE_AUTOPTR_CLEANUP_FUNC (UDisksObjectManagerClient, g_object_unref)
#endif

GType udisks_object_manager_client_get_type (void) G_GNUC_CONST;

GType udisks_object_manager_client_get_proxy_type (GDBusObjectManagerClient *manager, const gchar *object_path, const gchar *interface_name, gpointer user_data);

void udisks_object_manager_client_new (
    GDBusConnection        *connection,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GAsyncReadyCallback     callback,
    gpointer                user_data);
GDBusObjectManager *udisks_object_manager_client_new_finish (
    GAsyncResult        *res,
    GError             **error);
GDBusObjectManager *udisks_object_manager_client_new_sync (
    GDBusConnection        *connection,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GError                **error);

void udisks_object_manager_client_new_for_bus (
    GBusType                bus_type,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GAsyncReadyCallback     callback,
    gpointer                user_data);
GDBusObjectManager *udisks_object_manager_client_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error);
GDBusObjectManager *udisks_object_manager_client_new_for_bus_sync (
    GBusType                bus_type,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GError                **error);


G_END_DECLS

#endif /* __UDISKS_GENERATED_H__ */
